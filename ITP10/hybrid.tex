\documentclass[runningheads]{llncs}
\ifx\pdftexversion\undefined
  \usepackage[dvips]{graphics}
\else
  \usepackage[pdftex]{graphics}
\fi
\usepackage{amsmath}
%include format.tex
%\usepackage{rotating}
\usepackage{graphicx}
\input{diagrams}
\newcommand{\thetitle}{Automated Machine-Checked Hybrid System Safety Proofs}
\newcommand{\eelis}{Eelis van der Weegen$^{\dagger}$}
\newcommand{\herman}{Herman Geuvers$^{\dagger\ddagger}$}
\newcommand{\dan}{Dan Synek$^{\dagger}$}
\newcommand{\adam}{Adam Koprowski$^{\P}$}

% For the final version:
%\renewcommand{\todo}[1]{}
\newcommand{\ADAM}[1] {\todo{\textsc{Adam says}: #1}}
\newcommand{\HERMAN}[1] {\todo{\textsc{Herman says}: #1}}
\newcommand{\DAN}[1] {\todo{\textsc{Dan says}: #1}}
\newcommand{\EELIS}[1] {\todo{\textsc{Eelis says}: #1}}

\newcommand{\Exists}[2]{\exists_{#1} \, . \, #2}
\newcommand{\Forall}[2]{\forall_{#1} \, . \, #2}

\def\phi{\varphi}
\newcommand{\weg}[1]{}

\newcommand{\DN}{{\sf DN}\,}
\newcommand{\IR}{{\mathbf R}}
\newcommand{\Heat}{{\sf Heat}}
\newcommand{\Cool}{{\sf Cool}}
\newcommand{\Chec}{{\sf Check}}
\newcommand{\Off}{{\rm Off}} 
\newcommand{\Loc}{{\rm Loc}}
\newcommand{\AState}{{\rm AState}}
\newcommand{\State}{{\rm State}}
\newcommand{\Inv}{{\rm Inv}}
\newcommand{\Init}{{\rm Init}}
\newcommand{\Region}{{\rm Region}}
\newcommand{\List}{{\rm List}}
\newcommand{\Unsafe}{{\rm Unsafe}}
\newcommand{\Safe}{{\rm Safe}}
\newcommand{\AUnsafe}{{\rm AUnsafe}}
\newcommand{\ASafe}{{\rm ASafe}}
\newcommand{\Reach}{{\rm Reach}}
\newcommand{\AReach}{{\rm AReach}}
\newcommand{\guard}{{\rm guard}}
\newcommand{\reset}{{\rm reset}}
\newcommand{\trans}{\rightarrow_{CD}}
\newcommand{\doubleheadrightarrow}{\mathrel{\rightarrow\!\!\!\!\rightarrow}}
\newcommand{\ttrans}{\doubleheadrightarrow_{CD}}
\newcommand{\attrans}{\stackrel{A}{\doubleheadrightarrow_{CD}}}
\newcommand{\contrans}{\rightarrow_C}
\newcommand{\distrans}{\rightarrow_D}
\newcommand{\acontrans}{\stackrel{A}{\rightarrow_C}}
\newcommand{\adistrans}{\stackrel{A}{\rightarrow_D}}
\newcommand{\Dur}{{\IR_{\geq 0}}}
\newcommand{\leltdec}{{\tt leltdec}}
\newcommand{\leltdecoverlap}{{\tt leltdecoverlap}}
\newcommand{\leltdecDN}{{\tt leltdecDN}}

\newcommand{\overcontrans}{{\rm over\_cont\_trans}}
\newcommand{\overdistrans}{{\rm over\_disc\_trans}}
\usepackage{color}
\usepackage{amsmath}

\spnewtheorem*{propo}{Proposition}{\bfseries}{\rmfamily}

\def\commentbegin{\quad\{\ }
\def\commentend{\}}

\def\typeset{}

\usepackage{macros}

%\arrayhs % i.e. no page breaks in code blocks

% todo: mention deadlock

% meta:
%  - shoudl this be readable without having read alur?
% 
% presentation simplifications:
% - don't show concrete./abstract.State system. just use "State", "Point", "Location", etc.
% - use "a <= x <= b"
% - don't show backtic coercions or notation scope tags
% - some implicit arguments like plain eq instead of (@eq _)
% - leave out all the NoDup stuff.
% - instead of saying ProdCSetoid and CRasCSetoid, just say A*B and CR
% - "exists x, x `in` c /\ P" -> "exists x `in` c, P"
% - sigma projections and other coercions
% - use plain "=" for setoid equality.
% - patterns in fun's

\title{\thetitle}
%\subtitle{An Implementation of the Abstraction Method In Coq}

\author{Herman Geuvers\inst{1,2}, Adam Koprowski\inst{3}, Dan Synek\inst{1}, Eelis van der Weegen\inst{1}}
\authorrunning{H. Geuvers, A. Koprowski, D. Synek, E. van der Weegen}

%Institute for Computing and Information Sciences\\ 
%Faculty of Mathematics and Computer Science\\ 
\institute{
Radboud University Nijmegen 
\and
Technical University Eindhoven
\and
MLState, Paris
}

\usepackage[colorlinks,pdftitle=\thetitle,pdfauthor=]{hyperref}

\begin{document}

\maketitle

%\authorrunning{\em}
%\titlerunning{\em}

\begin{abstract}
We have developed a hybrid system safety prover, implemented in Coq
using the abstraction method introduced by Alur, Dang and Ivan\v ci\'c
(2006).  The development includes: a formalisation of the structure of
hybrid systems; a framework for the construction of an abstract
system (consisting of decidable ``overestimators'' of abstract
transitions and initiality) faithfully representing a (concrete)
hybrid system; a translation of abstract systems to graphs, enabling
the decision of abstract state reachability using a certified graph
reachability algorithm; a proof of the safety of an example hybrid
system generated using this tool stack. 
To produce fully certified safety proofs without relying on floating point computations, the development critically relies on the computable real number implementation part of the CoRN library of constructive mathematics formalised in Coq.
The development also features a nice interplay between constructive and 
classical logic via the double negation monad.


\end{abstract}

%\nocite{*}

\section{Introduction}

In \cite{alur}, Alur et al.\ present an automated method for hybrid system
safety verification in which one derives from the hybrid system of interest an \emph{abstract}
hybrid system, which is essentially a finite automaton whose traces are sufficiently representative of traces in the original system that unreachability in the abstract system (which can be decided using a standard graph algorithm) implies unreachability in the concrete system (which, being governed by continuous behaviors, cannot be decided so readily). Thus, the abstraction method brings the safety verification problem from a continuous and infinite domain into a discrete and finite domain, where it can be dealt with using standard graph algorithms.

The prototype implementation described in \cite{alur} was developed in
a conventional programming language, only has an informal correctness argument,
and uses ordinary floating point numbers to approximate the real numbers that are used in said argument. These factors limit the confidence one can justifiably have in safety judgements computed by this implementation, because (1) it is easy for bugs to creep into uncertified programs; (2) it is easy to make mistakes in informal correctness arguments; and (3) floating point computations are subject to rounding errors and representation artifacts.

The primary goal of our work is to increase this degree of confidence by developing a \emph{certified} reimplementation of the abstraction technique in Coq, a proof assistant based on a rich type theory that also functions as a (purely functional) programming language. The Coq system lets us develop the algorithms and their formal correctness proofs in tandem in a unified environment, addressing (1) and (2) above.

To address (3), we replace the floating point numbers with exact computable reals instead of floating point computation, using the certified exact real arithmetic library developed by O'Connor \cite{oconnor} for CoRN, our Coq repository of formalised constructive mathematics. \cite{corn} This change is much more than a simple change of representation, however; because computable reals only permit observation of arbitrarily close approximations, certain key operations on them (namely naive comparisons) are not decidable. The consequences of this manifest themselves in our development in several ways, which we discuss in some detail. Hence, our development also serves to showcase O'Connor's certified exact real arithmetic library applied to a concrete and practical problem.

On a separate note, we argue that the use of computable reals is not just a pragmatic choice necessitated by the need to actually compute, but is actually fundamentally appropriate considering their role in hybrid systems, where they represent physical quantities acted upon by a device with sensors and actuators. And in the real world, too, measurements are approximate.

The end result of our work is a framework with which one can specify (inside Coq) a concrete hybrid system, set some abstraction parameters, derive an abstract system, and use it to compute (either inside Coq itself or via extraction to OCaml) a safety proof for the concrete system.

\section{Hybrid Systems and the Abstraction method}
\label{sec:hybsys}
We briefly introduce the notion of a {\em linear hybrid system}, as
used by \cite{alur}, and we show how the abstraction method is used in
that paper in order to verify safety. There are various notions
(formal definitions) of hybrid systems
\cite{henziger,lynchvaandrager}. To illustrate the definition, we give
the example of a thermostat, which is the same as \cite{alur} uses as
a running example to illustrate the abstraction method. We will use
the same example to illustrate our formal verification in Coq.

\begin{center}
\begin{figure}[htb!]
%\begin{turn}{180}
\begin{center}
%    \includegraphics[scale=.6, viewport=0 500 700 710, clip]{FIGS/traject}
    \includegraphics[scale=.5]{FIGS/ThermoFig}
\end{center}
%\end{turn}
\caption{The Thermostat as an example of a Hybrid Systems \label{fig:thermostat}}
\end{figure}
\end{center}

A hybrid system is a model of how a software system, described as a
finite set of \emph{locations}, $\Loc$ 
%\footnote{We reserve the term ``state''
%  for something else.} 
with (discrete) transitions between them, acts
on and responds to a set of continuous variables (called the
\emph{continuous state space}), typically representing physical
properties of some environment (such as temperature and pressure).

In \cite{alur}, Alur requires that the continuous state space be a
convex polyhedron in $\IR^ n$. 
%In our definition of a hybrid system,
%we initially let the continuous state space be an arbitrary
%(constructive) setoid, called |Point|. We also explicitly require
%decidability of location equality.
In the running example of Figure \ref{fig:thermostat},
the discrete component consists of three locations (called $\Heat$, $\Cool$,
and $\Chec$), whose continuous state space is $\IR^2$,
where $\IR$ are the \emph{computable} reals as defined in CoRN. 
The $\Heat$ and $\Cool$ locations represent states in which the
thermostat heats and cools the environment it operates in,
respectively. The $\Chec$ state is a self-diagnostic state in which
the thermostat does not heat or cool. The first $\IR$ component in the
continuous state space represents an internally resettable clock,
while the second represents the temperature in the environment in
which the thermostat operates.

A \emph{State} in a hybrid system is a pair $(l, p)$ consisting of a
location $l$ and a point $p$ in the continuous state space
(representing the value of the continuous variables). We use $\State$
for the set of states of a hybrid system.

The {\em invariant\/} predicate defines, for each location, a set of
permitted values for the continuous variables. 
For the thermostat, the invariant is as follows: $$\Inv_{\Heat}(c,T) := T\leq 10\wedge c\leq 3,\quad \Inv_{\Cool}(C,t) := 5 \leq T,\quad \Inv_{\Chec} := c\leq 1.$$

A hybrid system also has a set of \emph{initial states}, for which we
will use the predicate $\Init(s)$.  For the thermostat example,
$\Init(l,c,T) := l= \Heat \wedge c= 0 \wedge 5 \leq T \leq 10.$
There is the obvious requirement that the invariant holds at each
initial state.


The remaining parts of a hybrid system (i.e.\ {\em flow}, {\em guard}
and {\em reset}) describe transitions between states, which, together
with the set of initial states, determine the set of \emph{reachable}
states, representing the possible behaviours exhibited by a
hypothetical real-world implementation of the hybrid system (as
software running on a device with sensors and actuators).

Each location in a concrete system has an accompanying \emph{flow
  function} which describes how the continuous variables change over
time while the system is in that location. The idea is that then
different locations correspond to different uses of actuators
available to the software system, the effects of which are described
by the flow function. For instance, in the thermostat, the flow
function corresponding to the $\Heat$ location will have the
temperature increase with time, modelling the effect of the heater
component in the imagined thermostat device.

In the canonical definition of hybrid systems, flow functions are
specified as solutions to differential equations describing the
dynamics of the continuous variables. We follow \cite{alur} in
abstracting from these, taking instead the solutions of these
differential equations, which are flow functions $\Phi$ which satisfy:
$$\Phi( p, 0) = p \quad \mbox{and} \quad \Phi (p, t + t') = \Phi (\Phi( p, t), t')$$
We now say that there is a (concrete) \emph{continuous transition}
from a state $(l, p)$ to a state $(l', p')$ if $l = l'$ and there is a
non-negative duration $d$ such that $p' = \Phi_l( p,d)$ with the
invariant for $l$ holding at every point along the way:
$$ (l,p) \contrans (l',p') := l=l' \wedge \Exists{d\in
\Dur}{\Phi_l(p, d) = p' \wedge \Forall{t}{0 \leq t\leq d \rightarrow
\Inv_l(\Phi_l (p, t))}}.$$

In case we are in $\IR ^2$, the flow function can be expressed as the
product of two flow functions: $\Phi_l(c,T,t) = (\phi_{l,1}(c,T,t),
\phi_{l,2}(c,T,t))$. In the thermostat example, as in many other
examples of hybrid systems, $\phi_{l,1}(c,T,t)$ does not depend on $T$
and $\phi_{l,2}(c,T)$ does not depend on $c$. We call this feature
{\em separability\/} of the flow function; our development currently
relies heavily on this property. Separability makes the form of the
flow functions simpler:
$$\Phi_l(c,T,t) = (\phi_{l,1}(c,t), \phi_{l,2}(T,t))$$

In the thermostat, for all locations, $\phi_{l,1}(c,d) = c + d$ (for
the clock) and $\phi_{\Heat,2}(T,d)= T + 2 * d$,
$\phi_{\\Cool,2}(T,d)= T * e^{-d}$, $\phi_{\Chec,2}(T,d)= T * e^{-
  \frac{1}{2}d}$.

Where continuous transitions describe the flow of continuous
variables, \emph{discrete} transitions between locations describe the
logic of the software system. Each such transition is comprised of two
components: a \emph{guard} predicate, and a \emph{reset} function. The
former defines a subset of the continuous state space in which the
transition is enabled (permitted), while the latter describes an
instantaneous change applied as a side effect of the transition, as
seen in the following definition of the discrete transition relation:
$$ (l,p) \distrans (l',p') := \guard_{l,l'}(p) \wedge \reset_{l,l'}(p)= p' \wedge \Inv_l(p) \wedge \Inv_{l'}(p')$$
It will be obvious from Figure \ref{fig:thermostat} what the guards
and reset functions are. The reset function resets the clock for all
but one of these transitions, and leaves the temperature variable as
is. Here we can discern a conceptual distinction between continuous
variables directly controlled by the system (such as the clock in the
thermostat), and variables that model a physical phenomenon and that
can only be observed (such as the temperature in the thermostat). This
distinction is not made explicit in the definition of a hybrid system;
in principle, nothing is stopping the thermostat from treating
temperature as a variable of the former kind and resetting its
value. However, this would simply make the system unimplementable.


A transition is either continuous or discrete $\trans:= \distrans \cup \contrans$. We now say that a state $s$ is \emph{reachable} if there is an initial state $i$ from which one can, by a finite number of transitions, end up in $s$ ($\ttrans$ is the transitive reflexive closure of $\trans$):
$$\Reach(s):=
    \Exists{i\in \State}{\Init(i) \wedge i \ttrans s}.$$
\weg{As mentioned before, the set of reachable states represents the
possible behaviours exhibited by a hypothetical real-world
implementation of the hybrid system (as software running on a device
with sensors and actuators).
}

The idea now is that the purpose of a hybrid system is typically to
keep the continuous variables within certain limits. In other words,
to limit the set of reachable states to some ``safe'' subset of the
complete state space. For the thermostat example, the intent is to
keep the temperature above $4.5$ degrees at all times, and so the safe
states are defined to be those in which we have $T > 4.5$: $\Safe(l,c,T) := T >4.5$ and $\Unsafe(l,c,T) := T\leq 4.5.$
The goal, then, is to verify that the reachable states are all safe.

\subsection{The Abstraction Method}
There are uncountably many traces in a hybrid system, so safety is
undecidable in general. In concrete situations, safety may be (easily)
provable, however, for example, if one finds the proper {\em proof
  invariant}. As proof-invariants are often hard to find, one would
like to have more automated heuristic methods for establishing
safety. This is what the {\em predicate abstraction method\/} of
\cite{alur} does. In general one divides the continuous state space
into a finite number of convex subsets (polygons), $A_1, \ldots, A_n$,
which yields a finite {\em abstract state space}, $\AState := \{ (l,
A_i) \mid l \in \Loc, 1\leq i \leq n \}$, with an obvious embedding
$A: \State \to \AState$ of concrete states into abstract states. On this
abstract state space, one immediately defines {\em abstract continuous
  transitions\/} and {\em abstract discrete transitions\/} as follows.
\begin{eqnarray*}
(l,P) \acontrans (l',Q) &:=& l=l' \wedge \Exists{p\in P, q\in Q}{(l,p) \contrans (l,q)}\\
(l,P) \adistrans (l',Q) &:=& \Exists{p\in P, q\in Q}{(l,p) \distrans (l,q)}.
\end{eqnarray*}
Now {\em abstract reachability\/} can be defined in the obvious way as
follows $\AReach(a) := \Exists{s_0\in\State}{\Init(s_0) \wedge A(s_0)
\attrans a}$, and also the predicates $\ASafe$ and $\AUnsafe$, stating
when abstract states are safe / unsafe are defined as expected.

This yields a finite transition system (where it may be undecidable if
there is a transition between two states!) which has the
obvious property indicated in Figure \ref{diag:abstraction}.
\begin{figure}[htb!]
$$\begin{diagram}
 s & \rArr_{CD} & s'&& s_0& \rArr_{CD} & s_1& \rArr_{CD} & s_2& \rArr_{CD} & \ldots\\
\dTo &         &\dTo &&\dTo & &\dTo &&\dTo & &\\
A(s)& \rArr^A_{CD} & A(s') && A(s_0)& \rArr^A_{CD} & A(s_1)& \rArr^A_{CD} & A(s_2)& \rArr^A_{CD} & \ldots\\
\end{diagram}$$
\caption{The abstraction function \label{diag:abstraction}}
\end{figure}
With this property, one can conclude safety of the concrete system
from safety of the abstract system: $$\text{if}\ \Forall{a\in \AState}{\AReach(a) \rightarrow \ASafe(a)}, \text{then}\ \Forall{s\in \State}{
\Reach(s) \rightarrow \Safe(s)}.$$

The interest and power of the abstraction method lies in two
facts. First, we do not need the {\em exact\/} definitions of
$\acontrans$ and $\adistrans$ to conclude safety of the concrete
system from safety of the abstract system. We only need the property
of diagram \ref{diag:abstraction}, so we can {\em overestimate\/}
$\acontrans$ and $\adistrans$ (that is: replace it with a transition
relation that allows more transitions). Second, there is a fairly good
heuristic for making the abstraction (how to divide the continuous
state space into regions) and how to decide whether there should be an
abstract transition from one abstract state to another.
This is indicated in figure \ref{fig:abstraction}.

\begin{center}
\begin{figure}[htb!]
%\begin{turn}{180}
%    \includegraphics[scale=.6, viewport=0 500 700 710, clip]{FIGS/traject}
    \includegraphics[scale=.5]{FIGS/traject}
    \includegraphics[scale=.4]{FIGS/AThermo-new3}
%\end{turn}
\caption{The abstraction function computed
\label{fig:abstraction}}
\end{figure}
\end{center}

On the left side we schematically indicate how one can try to
``follow'' the path that region $A$ takes when time passes and verify
whether this path intersects with region $B$. The idea of
overestimation is that one should only {\em not\/} put an arrow $A
\acontrans B$ if we positively know that the path of $A$ will avoid
$B$, which is the case for example for paths that follow the dashed lines.

On the right side we see the abstract state space indicated for the
location $\Heat$. The abstract state space consists of rectangles,
possibly degenerated (extending to $-\infty$ or $+\infty$). For the
bounds of these rectangles one takes the values that occur in the
specification of the hybrid system (see Figure
\ref{fig:thermostat}). According to \cite{alur}, this is a good
choice. (In case one cannot prove safety in this, there is of course
the opportunity for the user to refine it.)  The gray area indicates
that from these states also abstract discrete transitions are
possible. The dashed area is unreachable, because of the invariant for
the $\Heat$ location %prevents these states from being reachable.  
All the abstract
transitions from the rectangle $[0.5,1) \times[5,6)$ are shown: as the
    temperature flow function for $\Heat$ is $\phi_{\Heat,2}(T,d)= T +
    2 * d$, and the clock flow function is $\phi_{\Heat,1}(c,d) = c +
    d$, these are all the possible abstract transitions.

There is a slight subtlety with the abstract transitions that we want
to consider. If we just take $\attrans$ to be the reflexive transitive
closure of $\acontrans \cup \adistrans$, we get far too many abstract
traces. (There is no problem with the correctness of the method --
Figure \ref{diag:abstraction} still applies -- but we get way too many
traces to be able to prove any system safe.) The problem lies in the
fact that there is no transition from any point in $[0.5,1)
  \times[5,6)$ to $[0.5,1) \times[9,10)$, but the transitive closure
        of $\adistrans$ gives us such a transition anyway. 
% \ADAM{I will try to add some more explanation}
Using this method, \cite{alur} proves the correctness of the thermostat. 

\section{Formalisation}
We now describe the formalisation in Coq and the design choices
made. Some of the design choices were due to specifics in Coq or its
type theory CiC, while other are due to our choice to work with exact
real arithmetic and a constructive logic. We will mostly discuss the
latter design choices, because we feel they are most relevant. Technical details, including a tar file with the formalization can be found at {\tt http://www.xs4all.nl/~weegen/eelis/research/hybrid/} or \cite{hybrid-techreport}.

\subsection{(Concrete) Hybrid Systems}
\label{concrete}

We begin by showing our definition of a concrete system, the different
parts of which we discuss in the remainder of this section.

\begin{code}
Record System: Type :=
  { Point: CSetoid
  ; Location: Set
  ; Location_eq_dec: EqDec Location eq
  ; locations: ExhaustiveList Location
  ; State :=  Location x Point
  ; initial: State -> Prop
  ; invariant: State -> Prop
  ; invariant_initial: initial subsetof invariant
  ; invariant_stable: forall s, Stable (invariant s)
  ; flow: Location -> Flow Point
  ; guard: State -> Location -> Prop
  ; reset: Location -> Location -> Point -> Point  }.
\end{code}

This Coq definition defines the record type of ``Systems'', which
contains a field ``Point'', representing the continuous state space
and a field ``Location'', representing the set of locations. Here, we
take Point to be an arbitrary Constructive Setoid, which is basically
just a type with an equality on it. For Location, we assume a
decidable equality and we assume a finite enumeration (``exhaustive
list'') of locations. The other parts are as expected (``Flow Point''
is the type of flow functions on the type ``Point''), except for the
requirement that the invariant $\Inv_l$ is ``Stable'' for every
location $l$.

\subsection{Stability and Double Negation}
\label{dn}

A property $P$ ({\tt P: Prop}) is {\em stable\/} if $\neg \neg P \rightarrow P$ holds. 
Classically, this is trivially true, but constructively
not. 
%Especially when we work with real numbers, we don't have $\leltdec: \forall
%x, y \in \IR (x\leq y \vee y<x)$. This conforms with the view of real
%numbers as an infinite sequence of better approximations: if $x$
%converges to $0$ we will not be able to decide $x\leq 0 \vee 0<x$ in a
%finite amount of time.

In constructive logic, a proof of a
disjunction $A\vee B$ (where $A$ and $B$ are arbitrary propositions) is
either a proof of $A$ or a proof of $B$. Similarly, to have a
proof of $X \rightarrow A \vee B$ is to have a function that, given an $X$,
either returns a proof of $A$, or a proof of $B$. With this in mind,
suppose we try to implement $\leltdec: \forall
%x, y \in \IR (x\leq y \vee y<x)$. Then given $x$ and $y$ in
$\IR$, we are to produce a proof either of $x \leq y$ or of $y <
x$. Unfortunately, the nature of computable reals only lets us observe
arbitrarily close approximations of $x$ and $y$. Now suppose $x =
y$. Then no matter how closely we approximate $x$ and $y$, the error
margins (however small) will always leave open the possibility that
$y$ is really smaller than $x$. Consequently, we will never be able to
definitively conclude that $x \leq y$.

Computable reals do admit two variations of the proposition:
\begin{enumerate}
\item $\leltdecoverlap: \forall x y: \IR. ( x < y \rightarrow \forall z. (z \leq y \vee x \leq z))$
\item $\leltdecDN: \forall x y: \IR. \neg  \neg  (x \leq y \vee y < x)$
\end{enumerate}

Both are weaker than the original, and are less straightforward to
use. Nevertheless, this is the path we will take in our development,
because just taking $\leltdec$ as an axiom amounts to cheating.
%and partly because in some parts of the development, we may need to
%really ``run'' these lemmas to obtain $\leq$/$<$ proofs or to do a
%case distinction in an algorithm. Having an axiom, disables such
%algorithms to complete.
\weg{ 
A place where we definitely need the stability of the invariant is in
proving the obvious and useful property of {\em transitivity of the
  continuous transition relation}: Suppose we have $(l, p) \contrans
(l, p')$ and $(l, p')\contrans (l, p'')$ for location $l$ and points
$p, p', p''$. 
To show $(l, p)\contrans (l, p'')$, we must show (among other things)
%that
%$\Exists{d''\in \Dur}{\Phi_l(p, d'') = p''}$ -- for which we
%simply take $d''$ to be the sum of the durations from $p$
%to $p'$ and from $p'$ to $p''$ (call these $d$ and $d'$,
%respectively), and observe:
%\begin{eqnarray*}
%  \Phi_l(p, d + d') & =& \Phi_l( \Phi_l (p, d), d')\\
%    & =& \Phi_l(p', d')\\
%    & =& p'' \nonumber
%\end{eqnarray*}
%What remains is to show 
that the invariant holds at each point along the way. That is,
$$\forall t, 0 \leq t \leq d + d' \rightarrow \Inv_l( \Phi_L(p, t)).$$
We know this is true for $0 \leq t \leq d$, and we know that this is
true for $d \leq t \leq d + d'$. Classically, then, the proof is done,
for one can simply distinguish cases $t \leq d$ or $d < t$.  In our
transitivity proof, we will use the variant expressed using double
negation. Now we need only observe that $x \leq y$ is equivalent to $\neg(y < x)$, and that the law of the excluded middle holds under double negation. That is,
$\forall P( \neg  \neg  (P \vee \neg  P))$
is a trivial tautology.
}
A question that immediately arises is: How does one actually use this
doubly negated variant in proofs?  One practical way is to observe
that double negation, as a function on propositions, is a monad
\cite{wadler95monads}. Writing $\DN P$ for $\neg  \neg  P$, we have the following two key
operations that make $\DN$ a monad:

%format bind_DN
\begin{code}
  return_DN: forall A, A -> DN A
  bind_DN: forall A B, DN A -> (A -> DN B) -> DN B
\end{code}

The first expresses that any previously obtained result can always be
inserted ``into'' the monad. The second expresses that results inside
the monad may be used freely in proofs of additional properties in the
monad. For instance, one may $bind_{\DN}$ a proof of $\DN (x \leq y \vee y < x)$ 
(obtained from $\leltdecDN$ above) with a proof of $(x \leq y \vee y < x) \rightarrow \DN P$, yielding a proof of $\DN P$.
 
Thus, $\DN$ establishes a ``proving context'' in which one may make
use of lemmas yielding results inside $\DN$ that may not hold outside
of it (such as $\leltdecDN$), as well as lemmas yielding results
not in $\DN$, which can always be injected into $\DN$ using
$return_{\DN}$. The catch is that such proofs always end up with results
in $\DN$, which begs the question: what good is any of this? In
particular, can $\leltdecDN$ be used to prove anything not doubly
negated?
 
As it happens, there is the class of \emph{stable} propositions (that
are equivalent to their own double negation). Examples include
negations, non-strict inequalities on real numbers, and any decidable
proposition.
 
We have seen why we required invariant stability:
%in section \ref{concrete}: 
in the transitivity proof for continuous transitions
it allows
us to employ $\leltdecDN$ to do case distinction on the $t$ variable
when showing that the invariant holds at each point along the
composite path. That is, we simply bind $\leltdecDN t d$ of type
$\DN (t \leq d \vee d < t)$ with the straightforward proof of $(t \leq d
\vee d < t) \rightarrow \DN (\Inv_l(\Phi_l (p, t)))$, and
then pull the latter out of $\DN$ on account of its stability.
 
Invariants are typically conjunctions of inequalities, which are
stable only if the inequalities are non-strict. Hence, the limits on
observability of computable real numbers ultimately mean that our
development cannot cope with hybrid systems whose location invariants
use strict inequalities. We feel that this is not a terrible loss. In
section \ref{abstraction} we will see analogous limitations in the
choice of one's abstraction parameters.
 
%An important point to make here is that the $\DN$ version is also
%\emph{sufficient\/} for proving safety, because the ultimate goal to
%prove is $\forall s\in \State( \Unsafe(s) \rightarrow \neg\Reach(s))$.
%This is a stable proposition, because the conclusion is a negated
%proposition, so is we have prove it ``under $\DN$'' we can extract it
%and conclude safety.

\subsection{Abstract Hybrid Systems}
\label{abshybsys}
\label{abstraction}
We now want to define an abstract system and an abstraction function
satisfying the properties indicated in diagram
\ref{diag:abstraction}. However, this is not possible, because we
cannot make a case distinction like $x\leq 0 \vee 0< x$ and therefore
we can't define a function that sends a point $(c,T)$ to the rectangle $R$
it is in. We can define a function that approximates a point $(c,T)$
up to, say $\epsilon$ ($\epsilon >0$) and then decides to send that
point to the rectangle $R$ the approximation is in. This implies that,
when one is close to the edge of a rectangle,
\begin{itemize}
\item 
different {\em representations\/} of a point $(c,T)$ may be
sent to different rectangles,
\item
a point that is less than $\epsilon$ outside the rectangle $R$ may still be sent to $R$.
\end{itemize}
The second is very problematic, because the property for the
abstraction function $A$, as depicted in diagram
\ref{diag:abstraction} is now just false.

These may seem just anoying problems,
caused by the fact that our logic is constructive, but we claim it is
not. It is is a fact of physical reality that one can only get a
finite approximation of a measured value, so case distinctions like
$x\leq 0 \vee 0< x$ are unrealistic. Moreover, we claim that the
classical abstraction method allows one to prove the safety of systems
that are unreliable in practice. We will not expand on this here, but
suppose we add a fourth location $\Off$ to the thermostat of Figure
\ref{fig:thermostat}, with $\dot{T} = -1$, $\dot{c} =1$ and an arrow
from $\Heat$ to $\Off$ with guard $c\geq 2 \wedge T<9$. Clearly, if
the system can end up in location $\Off$, it is unsafe. Now, using
the classical abstraction method, there is no transition to any state
involving location $\Off$ from the initial state, because as soon as
$c\geq 2$, $T\geq 9$. However, when we get close to $c=2$, any small
mistake in the measurement of $T$ may send the system to $\Off$,
making the whole hybrid system very unreliable.

The good thing is that we don't really need the property in Diagram
\ref{diag:abstraction}, because we can do something better. 
\begin{itemize}
\item
We let regions in the abstract hybrid systems overlap (ideally as
little as possible, e.g.\ only at the edges).

\item
We replace the {\em abstract continuous transition\/} relation
$\acontrans$ by a function $\overcontrans$ that takes a region $R_0$
as input and outputs a {\em list of regions\/} including $R_0$: $(R_o,
R_1, \ldots, R_n)$ in such a way that $\cup_{0\leq i\leq n}R_i$ is an
overapproximation of the set of states reachable by a continuous step
from a state in $R_0$.\\
We do something similar for the {\em abstract discrete transition}, and obtain $\overdistrans :\Region \rightarrow List \Region$.
\item
We loosen the requirement on the abstraction function $A$; for $s \in \State$, we only require $\DN {\exists r\in \Region}{(s\in r)}$.
\end{itemize}

So, to summarize, if $s\contrans s'$, then we don't require
$A(s')$ to be in the list $\overcontrans(A(s))$, but we only require
$s'$ to be in the $\bigcup \overcontrans(A(s))$. 
%(Basically it should
%be in one of the regions in the list $\overcontrans(A(s))$.) 
This simple change relieves us from having to determine the exact
regions that points are in: they just should be covered. The functions
$\overcontrans$ and $\overdistrans$ yield a notion of {\em trace\/} in
the abstract hybrid system in the obvious way: starting from $R_0$,
take an $R_1$ in $\overcontrans( R_0)$, then an $R_2$ in
$\overdistrans(R_1)$, and so forth.

Whereas in a concrete hybrid system states consist of a location
paired with a point in the continuous state space, in an abstract
hybrid system states consist of a location paired with the ``name'' of
a region corresponding to a subset of the continuous state space.
From now on we will use a ``|concrete.|'' prefix for names like
|State| defined in section \ref{concrete}, which now have abstract
counterparts. |Region| is a field from a record type |Space| bundling
region sets with related requirements:

\begin{code}
  Record Space: Type :=
    { Region: Set
    ; Region_eq_dec: EqDec Region eq
    ; regions: ExhaustiveList Region
    ; NoDup_regions: NoDup regions
    ; in_region: Container Point Region
    ; regions_cover: forall (l: Location) (p: Point),
        invariant (l, p) -> DN { r: Region | p `elem` r }  }.
\end{code}

The |Container Point Region| type specified for |in_region| reduces to
|Point -> Region -> Prop|. |Container| is a type class that provides
the notation ``|x `elem` y|'', prettier than ``|in_region x
y|''. |regions_cover| expresses that each concrete point belonging to
a valid state must be represented by a region---a crucial ingredient
when arguing that unreachability in the abstract system implies
unreachability in the concrete system. The double negation in its
result type is both necessary and sufficient:

It is \emph{necessary} because |regions_cover| boils down to a
(partial) function that, given a concrete point, must select an
abstract region containing that point. This means that it must be able
to decide on which side of a border between two regions the given
point lies. As we saw in section \ref{dn}, that kind of decidability
is only available inside |DN| unless all region borders have
nontrivial overlap, which as we will see later is undesireable.

Fortunately, the double negation is also \emph{sufficient}, because we
will ultimately only use |regions_cover| in a proof of of |... -> ~
concrete.reachable s| (for some universally quantified variable s),
which, due to its head type being a negation, is stable, and can
therefore be proved in and then extracted from |DN|. Hence, we only
need |regions_cover|'s result in |DN|.

\subsection{Underestimation and Overestimation}
\label{estimation}

% It \emph{will} always terminate, so we are not writing a semidecision procedure either.
Ultimately, in our development we are writing a program that
\emph{attempts} to produce hybrid system safety proofs. Importantly,
we are \emph{not} writing a complete hybrid system safety decision
procedure: if the concrete system is unsafe or the abstraction method
fails, our program will simply not produce a safety proof. It might
seem, then, that we are basically writing a \emph{tactic} for a
particular problem domain. However, tactics in Coq are normally
written in a language called Ltac, and typically rely on things like
pattern matching on syntax. Our development, on the other hand, is
very much written in regular Gallina, with hardly any significant use
of Ltac. 

We define |underestimation P| to be either a proof of
|P|, or not. In Coq, either of the following will do:
\begin{code}
Definition underestimation (P: Prop): Set := option P.
Definition underestimation (P: Prop): Set := { b: bool | b = true -> P }.
\end{code}
The latter tends to work better with the |Program| family of commands
\cite{sozeau} which have special support for dependent pairs. Using
|Program|, an underestimation of the second variety may be
provisionally defined strictly as a bool, and then separately proved
to be a valid underestimation in a proof obligation generated by
|Program|. The second form also nicely illustrates why we call this an
underestimation: it may be |false| even when |P| holds. We can now
describe the functionality of our program by saying that it
underestimates hybrid system safety, yielding a term of type
|underestimation Safe|, where |Safe| is a proposition expressing
safety of a hybrid system.

Considered as theorems, underestimations are not very interesting,
because they can be trivially ``proved'' by taking
|false|/|None|. Hence, the value of our program is not witnessed by
the mere fact that it manages to produce terms of type
|underestimation Safe|, but rather by the fact that when run, it
actually manages to returns |true|/|Just P| for the hybrid system we
are interested in (e.g.\ the thermostat). It is for this reason that
we primarily think of the development as a program rather than a
proof, even though the program's purpose is to produce proofs.
The opposite of an underestimation is an overestimation:
\begin{code}
Definition overestimation (P: Prop): Set := { b: bool | b = false -> ~ P }.
\end{code}

Since hybrid system safety is defined as unreachability of unsafe
states, we may equivalently express the functionality of our
development by saying that it overestimates unsafe state
reachability. Indeed, most subroutines in our programs will be
overestimators rather than underestimators. Notions of overestimation
and underestimation trickle down through all layers of our
development, down to basic arithmetic. For instance, we employ
functions such as:

%format CRle_unapplied = <= "_{" CR "}"
%format CRle a b = a <= "_{" CR "}" b
%format Qpos = "\mathbb{Q}^{+}"
%format overestimate_CRle = overestimate "_{" CRle_unapplied "}"

%format epsilon = "\epsilon "

\begin{code}
overestimate_CRle (epsilon: Qpos): forall x y: CR, overestimation (CRle x y)
\end{code}
As discussed earlier, |CRle_unapplied| is not
decidable. |overestimate_CRle| merely makes a ``best effort'' to prove
|~ (CRle x y)| using |epsilon|-approximations. A smaller |epsilon|
will result in fewer spurious |true| results.




\subsection{Abstract Space Construction}
\label{abs.space.constr}

When building an abstract system, one is in principle free to divide
the continuous state space up whichever way one likes. However, if the
regions are too fine-grained, there will have to be very many of them
to cover the continuous state space of the concrete system, resulting
in poor performance. On the other hand, if the regions are too coarse,
they will fail to capture the subtleties of the hybrid system that
allow to prove it safe (if indeed it is safe at all).  Furthermore,
careless use of region overlap can result in undesireable abstract
transitions (and therefore traces), adversely affecting the abstract
system's utility
%(as we will discuss in detail in section \ref{trouble}).

In \cite{alur}, a heuristic for interval bound selection is described,
where the bounds are taken from the constants that occur in the
invariant, guard, and safety predicates. For the thermostat, we
initially attempted to follow this heuristic and use the same bounds,
but found that due to our use of computable reals, we had to tweak the
bounds somewhat to let the system successfully produce a safety
proof. 
Having to do this "tweaking" manually is obviously not idea. One may want to develop heuristics for this. 


Another way in which our thermostat regions differ from \cite{alur}
lies in the fact that our bounds are always inclusive, which means
adjacent regions overlap in lines. We will discuss this in more detail
later.

\subsection{Abstract Transitions and Reachability}
\label{abs.reach}
Once we have a satisfactory abstract |Space|, our goal is to construct
an overestimatable notion of abstract reachability implied by concrete
reachability, so that concrete unreachability results may be obtained
simply by executing the abstract reachability overestimator. We first overestimate the continuous transitions; we need the following definition for that.

\begin{code}
  Definition shared_cover
    `{Container concrete.State C} `{Container abstract.State D}
      (cs: C) (ss: D): Prop :=
        forall s: concrete.State, In s cs -> DN (exists r: abstract.State, In s r /\ In r ss).
\end{code}

The details of the |Container| type class are of no interest to us
right now; one may think of |C| and |D| as the types of lists over
concrete states, respectively over abstract states.  What matters is
that a ``container'' of concrete states is said to be sharedly-covered
by a ``container'' of abstract states if for each of the concrete
states in the former there is an abstract state in the latter that
contains it.
We state this in
terms of |Container|s so that the definition applies to any types
which have a reasonable notion of containment.

We now specify what the type of $\overcontrans$ should be.
\begin{code}
over_cont_trans: forall s: abstract.State,
  { p: list abstract.State | NoDup p /\ shared_cover
    (concrete.invariant `inter` (overlap s `compose` utilflip (concrete.cont_trans))) p }
\end{code}
So, |over_cont_trans s| should produce a list of abstract states |p|
without duplicates,
%(to enhance the graph reachability algorithm that
%we don't detail here, but that will do the actual computation of the
%reachability set), 
such that |p| is a shared cover of the collection
of concrete states |c| that satisfy the invariant and whose set of
origins under |concrete.cont_trans| have an overlap with |s|. In more
mathematical terms: |p| should form a shared cover of $\{ c \in \State
\mid \Inv(c) \wedge s\cap \{c' \mid c' \contrans c\} \neq \emptyset\}$.
We similarly specify |over_disc_trans| as an overestimator for
|concrete_disc_trans| and |over_initial| as an overestimator of
|concrete.initial|. 

We now consider the properties we require for |abstract.reachable|. The following basic specification we had in mind:

\begin{code}
Definition reachable_respect: Prop :=
  forall (s: concrete.State), concrete.reachable s ->
    forall (s': abstract.State), s `elem` s' -> abstract.reachable s'.
\end{code}
Which we chose because it implies
\begin{code}
forall (s: concrete.State)
  (exists s': abstract.State, s `elem` s' /\ ~ abstract.reachable s') ->
    ~ concrete.reachable s,
\end{code}
This expresses that to conclude unreachability of a concrete state,
one need only establish unreachability of \emph{any} abstract state
that contains it. However, this definition neglects to facilitate {\em
  sharing}: remember that a concrete state may be in more then one
abstract state. When abstract states ``share'' the burden of
reachability, one should establish unreachability of \emph{all}
abstract states containing the concrete state. Hence, what we really
want is an |abstract.reachable| satisfying:
\begin{code}
forall s: concrete.State,
  (forall s': abstract.State, s `elem` s' -> ~ abstract.reachable s') ->
  ~ concrete.reachable s.
\end{code}
\weg{
This property follows from the following new definition of |reachable_respect| we will use:
\begin{code}
Definition reachable_respect: Prop :=
  shared_cover concrete.reachable abstract.reachable.
\end{code}
}

\subsection{Underestimating Safety}
\label{underestimatingsafety}

In the next section we show that thanks to decidability of our
transition and initiality overstimators, |abstract.reachable| is
decidable. But first we show how a
decision procedure for |abstract.reachable| lets us underestimate
hybrid system safety, and in particular, lets us obtain a proof of
thermostat safety. So suppose we have |reachable_dec: decider abstract.reachable|
\weg{
And suppose we are given the following specification of unsafe concrete states, covered by a finite list of abstract states:
\begin{code}
  Variables
    (unsafe: concrete.State -> Prop)
    (astates: list abstract.State)
    (astates_cover_unsafe: forall s, unsafe s -> forall r, s `elem` r -> r `elem` astates).
\end{code}

Then, using |reachable_dec| and |unreachable_respect|, we can easily define
\begin{code}
  Definition over_unsafe_reachable: overestimation (overlap unsafe concrete.reachable).
\end{code}
Taking |unsafe := thermo_unsafe| and a suitable abstract cover, we obtain
\begin{code}
  Definition over_thermo_unsafe_reachable:
    overestimation (overlap thermo_unsafe concrete.reachable).
\end{code}
}
Recall that |ThermoSafe| was defined as |thermo_unsafe `subsetof` concrete.unreachable| in section \ref{concrete}. Since we trivially have |~ overlap unsafe concrete.reachable -> ThermoSafe|, we also have:
\begin{code}
Definition under_thermo_unsafe_unreachable: underestimation ThermoSafe.
\end{code}
Finally, we \emph{run} the underestimation:
\begin{code}
Theorem: ThermoSafe.
Proof.
  apply (underestimation_true under_thermo_unsafe_unreachable).
  vm_compute.  reflexivity.
Qed.
\end{code}
|underestimation_true| is a tiny utility of type |forall P (o: underestimation P), o = true -> P|, whose application in the proof reduces the goal to
\begin{code}under_thermo_unsafe_unreachable = true.\end{code} The |vm_compute| tactic invocation then forces evaluation of the left hand side, which will in turn evaluate |over_thermo_unsafe_reachable|, which will evaluate |reachable_dec|, which will evaluate the overestimators of the continuous and discrete transitions. This process, which takes about 35 seconds on a modern desktop machine, eventually reduces |under_thermo_unsafe_unreachable| to |true|, leaving |true = true|, proved by |reflexivity|.

We can now also clearly see what happens when the abstraction method ``fails'' due to poor region selection, overly simplistic transition/initiality overestimators, or plain unsafety of the system. In all these cases, |vm_compute| reduces |under_thermo_unsafe_unreachable| to |false|, and the subsequent |reflexivity| invocation will fail.

This concludes the high level story of our development. What remains
are the implementation of |reachable_dec| in terms of the decidable
overestimators for abstract initiality and continuous and discrete
transitions, and the implementation of those overestimators
themselves. The former is a formally verified graph reachability
algorithm, that we don't detail here. The overestimator for continuous
transitions, |over_cont_trans| will be detailed in the next section
for the thermostat case.

\subsection{Overestimating Continuous Abstract Transitions}
\label{over_cont_trans}

We now discuss the implementation of  |over_cont_trans|:
Given two regions |r_src| and |r_dst|, 
%we want to
%rule out the existence of concrete continuous transitions from points
%in |r_src| to points |r_dst|. Clearly, 
if we can determine that there
are no points in |r_src| which the flow function maps to points in
|r_dst|, then there need be no abstract continuous transition between |r_src|
and |r_dst|. Clearly, this is impossible to
meaningfully overestimate for a general flow function and general
regions. However, the thermostat posesses three key properties that
we can exploit:
\begin{enumerate}
\item its continuous space is of the form $\IR^n$;
\item abstract regions correspond to multiplied $\IR$ intervals;
\item its flow functions are both {\em separable\/} and {\em range invertible}.
\end{enumerate}

The notion of {\em separability\/} has already been discussed in
Section \ref{sec:hybsys}.
%The thermostat's flow function (in any
%location) is separable by construction.

A flow function |f| on |CR| is {\em range invertible\/} if
\begin{code}
  exists (range_inverse: OpenRange -> OpenRange -> OpenRange),
    forall (a: OpenRange) (p: CR), p `elem` a ->
    forall (b: OpenRange) (d: Duration), f p d `elem` b -> d `elem` range_inverse a b
\end{code}
Here, |OpenRange| represents potentially unbounded intervals in $\IR$
(with bounds closed if present. In other words, if $\phi : \IR^2
\rightarrow \IR$ is a flow function with range inverse $F$ and $a,b$
are intervals in $\IR$, then $F(a,b)$ is an interval that contains all
$t$ for which $\phi(x,t)\in b$ for some $x\in a$. 
%So $F(a,b)$ should
%contain all durations $t$ that take some elements of $a$ to some
%element of $b$ via flow $\phi$.
Range invertibility is a less demanding alternative to point invertibility: $\phi^{-1}$ is the {\em point inverse\/} of $\phi$ if $\forall x,y\in \IR (\phi (x, \phi^-1(x,y)) =y)$. So a point inverse $\phi^{-1}(x,y)$ computes the exact time it takes to go from $x$ to $y$ via flow $\phi$.
%We need range invertibility because the exponential flow functions are
%not point invertible.

In the formalization we use a modest library
of flow functions when defining the thermostat's flow. Included in
that library are range-inverses, which consequently automatically
apply to the thermostat's flow. Hence, no ad-hoc work is needed to
show that the thermostat's flow functions are range-invertible.
Having defined the class of separable range-invertible flow functions,
and having argued that the thermostat's flow is in this class, we now
show how to proceed with our overestimation of existence of points in
|r_src| which the flow function map to points in |r_dst|. 
Regions in the abstract space for our thermostat are basically pairs
of regions in the composite spaces, so |r_src| and |r_dst| can be
written as |(r_src_temp, r_src_clock)| and |(r_dst_temp,
r_dst_clock)|, respectively, where each of these four components are
intervals.

We now simply use an |OpenRange| overlap overestimator of type
\begin{code}
Qpos -> forall a b: OpenRange, overestimation (overlap a b)
\end{code}
(defined in terms of things like |overestimate_CRle| shown in section \ref{estimation}) to overestimate whether the following three intervals overlap:
\begin{enumerate}
\item |[0, inf]|
\item |range_inverse temp_flow r_src_temp r_dst_temp|
\item |range_inverse clock_flow r_src_clock r_dst_clock|
\end{enumerate}
For a visual explanation, one may consult the left drawing in Figure
\ref{fig:abstraction} and view |r_src_clock| as $[a_1,b_1]$,
|r_dst_clock| as $[c_1,d_1]$ etc.  Overlap of 2 and 3 is equivalent to
existence of a point in |r_src| from which one can flow to a point in
|r_dst|. After all, if these two range inverses overlap, then there is
a duration |d| that takes a certain temperature value in |r_src_temp|
to a value in |r_dst_temp| and also takes a certain clock value in
|r_src_clock| to a value in |r_dst_clock|. If 2 and 3 do \emph{not}
overlap, then either it takes so long for the temperature to flow from
|r_src_temp| to |r_dst_temp| that any clock value in |r_src_clock|
would ``overshoot'' |r_dst_clock|, or vice versa. Finally, if 1 does
not overlap with 2 and 3, then apparently one could only flow backward
in time, which is not permitted. Hence, overlap of these three ranges
is a necessary condition for existence of concrete flow from points in
|r_src| to points in |r_dst|, and so our |abstract.cont_trans|
overestimator may justifiably return ``false'' when the overlap
overestimator manages to prove absence of overlap.


\section{Related work}

\emph{Verification} of hybrid systems is an active field of research and
there is a number of tools developed with this goal in mind;
see \cite{HST} for a comprehensive list.
Most of them are based on abstract refinement methods, either
using box representations \cite{Kow96,Kow98}
or with polyhedra approximations \cite{alur,Chu99,Cla03}.

Many of those tools are implemented in MATLAB \cite{MATLAB}
and those using some general programming language of choice
most often rely on standard floating point arithmetic, that
comes with its rounding errors. Few tools that address 
this problem include 
PHAVer \cite{PhaVER}, that relies on the Parma Polyhedra Library \cite{Parma} 
for exact computations with non-convex polyhedra 
and 
HSolver \cite{HSolver}, that is based on the constraint solver 
RSolver \cite{RSolver}.

\emph{Formal verification} becomes more and more important, especially in the
field of hybrid systems, which are used to model safety critical systems 
of growing complexity. There has been previous work on using general purpose 
theorem provers for verification of hybrid systems: see \cite{Mum01,Hen98} 
and \cite{Man98,Man01} for works using, respectively, PVS and STeP. 
KeYmaera \cite{KeYmaera} is a dedicated interactive theorem prover for 
specification and verification logic for hybrid systems. It combines
deductive, real algebraic, and computer algebraic prover technologies
and allows users to model hybrid systems, specify their properties
and prove them in a semi-automated way.

However, to the best of our knowledge, none of the previous work nor tools 
relies on a precise model of real number computations completely verified 
in a theorem prover; such as the model of CoRN used in this work.

\section{Conclusions and further research}
The presented verification of hybrid systems in Coq gives a nice
showcase of proof-by-computation-on-computable-reals. The computable
reals in CoRN do really complicated things for us, by approximating
values for various real number exprseeions at great precision. The
development also contains some nice layers of abstraction, involving
the sophisticated use of type classes, e.g.\ the systematic use of
estimators to make tactic-like optional-deciders, at each level in the
stack and the use of the double negation monad.

It is to be seen how far this automated verification approach can be
taken, given the fact that we have limited ourselves to hybrid systems
with separable reset and flow functions that are monotone, and with a
stable invariants. There is still a lot of room for more clever
heuristics with less restrictive preconditions. The heuristic in
\cite{alur} for bound selection doesn't work out of the box, but
manual tweaking is obviously not ideal, so some more experimentation
is required here. Finally, in case safety cannot be proved, one would
like the system to generate an ``offending trace'' automatically,
which can the be inspected by the user.

%\bibliographystyle{splncs}
\bibliographystyle{plain}
%\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{paper}

\end{document}
