\documentclass[runningheads]{llncs}
\ifx\pdftexversion\undefined
  \usepackage[dvips]{graphics}
\else
  \usepackage[pdftex]{graphics}
\fi
\usepackage{amsmath}
%include format.tex
%\usepackage{rotating}
\usepackage{graphicx}
\input{diagrams}
\newcommand{\thetitle}{Automated Machine-Checked Hybrid System Safety Proofs}
\newcommand{\eelis}{Eelis van der Weegen$^{\dagger}$}
\newcommand{\herman}{Herman Geuvers$^{\dagger\ddagger}$}
\newcommand{\dan}{Dan Synek$^{\dagger}$}
\newcommand{\adam}{Adam Koprowski$^{\P}$}

% For the final version:
%\renewcommand{\todo}[1]{}
\newcommand{\ADAM}[1] {\todo{\textsc{Adam says}: #1}}
\newcommand{\HERMAN}[1] {\todo{\textsc{Herman says}: #1}}
\newcommand{\DAN}[1] {\todo{\textsc{Dan says}: #1}}
\newcommand{\EELIS}[1] {\todo{\textsc{Eelis says}: #1}}

\newcommand{\Exists}[2]{\exists_{#1} \, . \, #2}
\newcommand{\Forall}[2]{\forall_{#1} \, . \, #2}

\def\phi{\varphi}
\newcommand{\weg}[1]{}

\newcommand{\DN}{{\sf DN}\,}
\newcommand{\IR}{{\mathbf R}}
\newcommand{\Heat}{{\sf Heat}}
\newcommand{\Cool}{{\sf Cool}}
\newcommand{\Chec}{{\sf Check}}
\newcommand{\Off}{{\rm Off}} 
\newcommand{\Loc}{{\rm Loc}}
\newcommand{\AState}{{\rm AState}}
\newcommand{\State}{{\rm State}}
\newcommand{\Inv}{{\rm Inv}}
\newcommand{\Init}{{\rm Init}}
\newcommand{\Region}{{\rm Region}}
\newcommand{\List}{{\rm List}}
\newcommand{\Unsafe}{{\rm Unsafe}}
\newcommand{\Safe}{{\rm Safe}}
\newcommand{\AUnsafe}{{\rm AUnsafe}}
\newcommand{\ASafe}{{\rm ASafe}}
\newcommand{\Reach}{{\rm Reach}}
\newcommand{\AReach}{{\rm AReach}}
\newcommand{\guard}{{\rm guard}}
\newcommand{\reset}{{\rm reset}}
\newcommand{\trans}{\rightarrow_{CD}}
\newcommand{\doubleheadrightarrow}{\mathrel{\rightarrow\!\!\!\!\rightarrow}}
\newcommand{\ttrans}{\doubleheadrightarrow_{CD}}
\newcommand{\attrans}{\stackrel{A}{\doubleheadrightarrow_{CD}}}
\newcommand{\contrans}{\rightarrow_C}
\newcommand{\distrans}{\rightarrow_D}
\newcommand{\acontrans}{\stackrel{A}{\rightarrow_C}}
\newcommand{\adistrans}{\stackrel{A}{\rightarrow_D}}
\newcommand{\Dur}{{\IR_{\geq 0}}}
\newcommand{\leltdec}{{\tt leltdec}}
\newcommand{\leltdecoverlap}{{\tt leltdecoverlap}}
\newcommand{\leltdecDN}{{\tt leltdecDN}}

\newcommand{\overcontrans}{{\rm over\_cont\_trans}}
\newcommand{\overdistrans}{{\rm over\_disc\_trans}}
\usepackage{color}
\usepackage{amsmath}

\spnewtheorem*{propo}{Proposition}{\bfseries}{\rmfamily}

\def\commentbegin{\quad\{\ }
\def\commentend{\}}

\def\typeset{}

\usepackage{macros}

%\arrayhs % i.e. no page breaks in code blocks

% todo: mention deadlock

% meta:
%  - shoudl this be readable without having read alur?
% 
% presentation simplifications:
% - don't show concrete./abstract.State system. just use "State", "Point", "Location", etc.
% - use "a <= x <= b"
% - don't show backtic coercions or notation scope tags
% - some implicit arguments like plain eq instead of (@eq _)
% - leave out all the NoDup stuff.
% - instead of saying ProdCSetoid and CRasCSetoid, just say A*B and CR
% - "exists x, x `in` c /\ P" -> "exists x `in` c, P"
% - sigma projections and other coercions
% - use plain "=" for setoid equality.
% - patterns in fun's

\title{\thetitle}
%\subtitle{An Implementation of the Abstraction Method In Coq}

\author{Herman Geuvers\inst{1,2}, Adam Koprowski\inst{3}, Dan Synek\inst{1}, Eelis van der Weegen\inst{1}}
\authorrunning{H. Geuvers, A. Koprowski, D. Synek, E. van der Weegen}

%Institute for Computing and Information Sciences\\ 
%Faculty of Mathematics and Computer Science\\ 
\institute{
Radboud University Nijmegen 
\and
Technical University Eindhoven
\and
MLState, Paris
}

\usepackage[colorlinks,pdftitle=\thetitle,pdfauthor=]{hyperref}

\begin{document}

\maketitle

%\authorrunning{\em}
%\titlerunning{\em}

\begin{abstract}
We have developed a hybrid system safety prover, implemented in Coq
using the abstraction method introduced by Alur, Dang and Ivan\v ci\'c
(2006).  The development includes: a formalisation of the structure of
hybrid systems; a framework for the construction of an abstract
system (consisting of decidable ``overestimators'' of abstract
transitions and initiality) faithfully representing a (concrete)
hybrid system; a translation of abstract systems to graphs, enabling
the decision of abstract state reachability using a certified graph
reachability algorithm; a proof of the safety of an example hybrid
system generated using this tool stack. 
To produce fully certified safety proofs without relying on floating point computations, the development critically relies on the computable real number implementation part of the CoRN library of constructive mathematics formalised in Coq.
The development also features a nice interplay between constructive and 
classical logic via the double negation monad.


\end{abstract}

%\nocite{*}

\section{Introduction}

In \cite{alur}, Alur et al.\ present an automated method for hybrid system
safety verification in which one derives from the hybrid system of interest an \emph{abstract}
hybrid system, which is essentially a finite automaton whose traces are sufficiently representative of traces in the original system that unreachability in the abstract system (which can be decided using a standard graph algorithm) implies unreachability in the concrete system (which, being governed by continuous behaviors, cannot be decided so readily). Thus, the abstraction method brings the safety verification problem from a continuous and infinite domain into a discrete and finite domain, where it can be dealt with using standard graph algorithms.

The prototype implementation described in \cite{alur} was developed in
a conventional programming language, only has an informal correctness argument,
and uses ordinary floating point numbers to approximate the real numbers that are used in said argument. These factors limit the confidence one can justifiably have in safety judgements computed by this implementation, because (1) it is easy for bugs to creep into uncertified programs; (2) it is easy to make mistakes in informal correctness arguments; and (3) floating point computations are subject to rounding errors and representation artifacts.

Our goal is to increase this degree of confidence by developing a \emph{certified} reimplementation of the abstraction technique in Coq, a proof assistant based on a rich type theory that also functions as a (purely functional) programming language. The Coq system lets us develop the algorithms and their formal correctness proofs in tandem in a unified environment, addressing (1) and (2) above.

To address (3), we replace the floating point numbers with exact computable reals instead of floating point computation, using the certified exact real arithmetic library developed by O'Connor \cite{oconnor} for CoRN, our Coq repository of formalised constructive mathematics. \cite{corn} This change is much more than a simple change of representation, however; because computable reals only permit observation of arbitrarily close approximations, certain key operations on them (namely naive comparisons) are not decidable. The consequences of this manifest themselves in our development in several ways, which we discuss in some detail. Hence, our development also serves to showcase O'Connor's certified exact real arithmetic library applied to a concrete and practical problem.

On a separate note, we argue that the use of computable reals is not just a pragmatic choice necessitated by the need to compute, but is actually fundamentally appropriate considering their role in hybrid systems, where they represent physical quantities acted upon by a device with sensors and actuators. In the real world, too, measurements are approximate.

The end result of our work is a framework with which one can specify (inside Coq) a concrete hybrid system, set some abstraction parameters, derive an abstract system, and use it to compute (either inside Coq itself or via extraction to OCaml) a safety proof for the concrete system.

\section{Hybrid Systems and the Abstraction method}
\label{sec:hybsys}
In general, a hybrid system is a model of how a software system (running on a device with sensors and actuators), described as a finite set of \emph{locations}
%\footnote{We reserve the term ``state'' for something else.}
with (discrete) transitions between them, acts
on and responds to a set of continuous variables (called the
\emph{continuous state space}), typically representing physical
properties of some environment (such as temperature and pressure).

There are many varieties of hybrid systems \cite{henziger,lynchvaandrager}. We follow \cite{alur} in considering so-called \emph{linear hybrid systems}\weg{ (to be defined momentarily)}. To illustrate the definition and the abstraction process, we use as an example a hybrid system expressing the operation of a thermostat (this is the same example used in \cite{alur}), shown in Figure \ref{fig:thermostat}.


%format IR = "\mathbb{R}"
%format pow x y = x "^{" y "}"
%format cross = "\times "

%In \cite{alur}, Alur requires that the continuous state space be a
%convex polyhedron in |pow IR n|.
%In our definition of a hybrid system,
%we initially let the continuous state space be an arbitrary
%(constructive) setoid, called |Point|. We also explicitly require
%decidability of location equality.


The thermostat has three locations. The first two, $\Heat$ and $\Cool$, represent states in which the thermostat heats and cools the environment it operates in, respectively. The third, $\Chec$, represents a self-diagnostic state in which the thermostat does not heat or cool. The continuous state space of the thermostat consists of two continuous variables denoting an internally resettable clock $c$ and the temperature $T$ in the environment in which the thermostat operates.

With each location is associated an \emph{invariant} predicate defining the set of
permitted values for the continuous variables while in that location. The invariants for the thermostat are: $$\Inv_{\Heat} := c\leq 3 \wedge T\leq 10,\quad \Inv_{\Cool} := 5 \leq T,\quad \Inv_{\Chec} := c\leq 1.$$

\begin{center}
\begin{figure}[htb!]
%\begin{turn}{180}
\begin{center}
%    \includegraphics[scale=.6, viewport=0 500 700 710, clip]{FIGS/traject}
    \includegraphics[scale=.5]{FIGS/ThermoFig}
\end{center}
%\end{turn}
\caption{The Thermostat as an example of a Hybrid Systems \label{fig:thermostat}}
\end{figure}
\end{center}


The \emph{initial states} of a hybrid system are determined by a predicate $\Init$. For the thermostat,
$\Init(l,c,T) := l= \Heat \wedge c= 0 \wedge 5 \leq T \leq 10.$

%There is the obvious requirement that the invariant holds at each initial state.

The remaining parts of a hybrid system (described below) describe transitions between states, which, together
with the set of initial states, determine the set of \emph{reachable}
states, representing the possible behaviours exhibited by a
hypothetical real-world implementation of the hybrid system (as
software running on a device with sensors and actuators).

Each location in a hybrid system has an accompanying \emph{flow function} which describes how the continuous variables change over
time while the system is in that location. The idea is that different locations correspond to different uses of actuators
available to the software system, the effects of which are reflected in the flow function. For instance, in the thermostat, the flow
function corresponding to the $\Heat$ location will have the
temperature increase over time, modelling the effect of the heater
component in the imagined thermostat device.

In the canonical definition of hybrid systems, flow functions are
specified as solutions to differential equations describing the
dynamics of the continuous variables. We follow \cite{alur} in
abstracting from these, taking instead the solutions of these
differential equations, which are flow functions $\Phi$ which satisfy:
$$\Phi(p, 0) = p \quad \mbox{and} \quad \Phi (p, d + d') = \Phi (\Phi(p, d), d')$$
We now say that there is a (concrete) \emph{continuous transition}
from a state $(l, p)$ to a state $(l, p')$ if there is a
non-negative duration $d$ such that $p' = \Phi_l(p,d)$ with the
invariant for $l$ holding at every point along the way:
$$ (l,p) \contrans (l',p') := l = l' \wedge \Exists{d\in
\Dur}{\Phi_l(p, d) = p' \wedge \Forall{0 \leq t\leq d}{\Inv_l(\Phi_l (p, t))}}.$$

A flow function on |pow IR 2| can be expressed as the
product of two flow functions: $\Phi_l((c,T),d) = (\phi_{l,c}((c,T),d),
\phi_{l,T}((c,T),d))$. In the thermostat example, as in many other
examples of hybrid systems, $\phi_{l,c}((c,T),d)$ does not actually depend on $T$
and $\phi_{l,T}((c,T),d)$ does not actually depend on $c$. We call this feature
{\em separability\/} of the flow function. Our development currently
relies heavily on this property. Separability makes the form of the
flow functions simpler:
$$\Phi_l((c,T),t) = (\phi_{l,c}(c,t), \phi_{l,T}(T,t))$$

In the thermostat, $\phi_{l,c}(c,d) = c + d$ for all locations $l$, $\phi_{\Heat,T}(T,d)= T + 2 d$,
$\phi_{\\Cool,T}(T,d)= T * e^{-d}$, $\phi_{\Chec,T}(T,d)= T * e^{- \frac{1}{2}d}$.

Where continuous transitions describe the flow of continuous
variables, \emph{discrete} transitions between locations describe the
logic of the software system. Each such transition is comprised of two
components: a \emph{guard} predicate defining a subset of the continuous state
space in which the transition is enabled (permitted), and a \emph{reset} function
describing an
instantaneous change applied as a side effect of the transition, as
seen in the following definition of the discrete transition relation:
$$ (l,p) \distrans (l',p') := \guard_{l,l'}(p) \wedge \reset_{l,l'}(p)= p' \wedge \Inv_l(p) \wedge \Inv_{l'}(p')$$
It will be obvious from Figure \ref{fig:thermostat} what the guards
and reset functions are.

\weg{
The reset function resets the clock for all
but one of these transitions, and leaves the temperature variable as
is. Here we can discern a conceptual distinction between continuous
variables directly controlled by the system (such as the clock in the
thermostat), and variables that model a physical phenomenon and that
can only be observed (such as the temperature in the thermostat). This
distinction is not made explicit in the definition of a hybrid system;
in principle, nothing is stopping the thermostat from treating
temperature as a variable of the former kind and resetting its
value. However, this would simply make the system unimplementable.
}

A transition is either continuous or discrete: $\trans:= \distrans \cup \contrans$. We now say that a state $s$ is \emph{reachable} if there is an initial state $i$ from which one can, by a finite number of transitions, end up in $s$ ($\ttrans$ is the transitive reflexive closure of $\trans$):
$$\Reach(s):=
    \Exists{i\in \State}{\Init(i) \wedge i \ttrans s}.$$
\weg{As mentioned before, the set of reachable states represents the
possible behaviours exhibited by a hypothetical real-world
implementation of the hybrid system (as software running on a device
with sensors and actuators).
}

The object of hybrid system safety verification is to show that the set of reachable states is a subset of a predefined set of ``safe'' states. For the thermostat, the intent is to
keep the temperature above $4.5$ degrees at all times, and so we define $\Safe(c,T) := T > 4.5$ (and $\Unsafe(c,T)$ as its complement).

\subsection{The Abstraction Method}
There are uncountably many traces in a hybrid system, so safety is
undecidable in general. In concrete cases, however, safety may be (easily)
provable if one finds the proper {\em proof invariant}. Unfortunately these
are often hard to find, so we prefer methods that are more easily automated. The \emph{predicate abstraction} method of \cite{alur} is one such method.

The idea is to divide the continuous state space
into a finite number of convex subsets (polygons), $A_1, \ldots, A_n$,
which yields a finite {\em abstract state space}, $\AState := \{ (l,
A_i) \mid l \in \Loc, 1\leq i \leq n \}$, with an obvious embedding
$A: \State \to \AState$ of concrete states into abstract states. On this
abstract state space, one immediately defines {\em abstract continuous
  transitions\/} and {\em abstract discrete transitions\/} (both potentially undecidable) as follows.
\begin{eqnarray*}
(l,P) \acontrans (l',Q) &:=& l=l' \wedge \Exists{p\in P, q\in Q}{(l,p) \contrans (l,q)}\\
(l,P) \adistrans (l',Q) &:=& \Exists{p\in P, q\in Q}{(l,p) \distrans (l,q)}.
\end{eqnarray*}
Now {\em abstract reachability\/} can be defined in the obvious way as
follows $\AReach(a) := \Exists{s_0\in\State}{\Init(s_0) \wedge A(s_0)
\attrans a}$, and also the predicates $\ASafe$ and $\AUnsafe$, stating
when abstract states are safe / unsafe are defined as expected.

Traces in the finite transition system constructed this way are sufficiently representative (see Figure \ref{diag:abstraction}.) of those in the original (concrete) system that one can conclude safety of the latter from safety of the abstract system:
$$\text{if}\ \Forall{a\in \AState}{\AReach(a) \rightarrow \ASafe(a)}, \text{then}\ \Forall{s\in \State}{
\Reach(s) \rightarrow \Safe(s)}.$$


\begin{figure}[htb!]
$$\begin{diagram}
 s & \rArr_{CD} & s'&& s_0& \rArr_{CD} & s_1& \rArr_{CD} & s_2& \rArr_{CD} & \ldots\\
\dTo &         &\dTo &&\dTo & &\dTo &&\dTo & &\\
A(s)& \rArr^A_{CD} & A(s') && A(s_0)& \rArr^A_{CD} & A(s_1)& \rArr^A_{CD} & A(s_2)& \rArr^A_{CD} & \ldots\\
\end{diagram}$$
\caption{The abstraction function \label{diag:abstraction}}
\end{figure}


The interest and power of the abstraction method lies in two
facts. First, we do not need the {\em exact\/} definitions of
$\acontrans$ and $\adistrans$ to conclude safety of the concrete
system from safety of the abstract system. We only need the property
of diagram \ref{diag:abstraction}, so we can {\em overestimate\/}
$\acontrans$ and $\adistrans$ (i.e. replace it with a transition
relation that allows more transitions). Second, there are good
heuristics for how to divide the continuous
state space into regions, and how to decide whether there should be an
abstract transition from one abstract state to another.

This is indicated in figure \ref{fig:abstraction}. The left side illustrates
the challenge: given abstract regions $A$ and $B$, we are to determine
whether nonnegative flow durations might permit flow from points in $A$ to points in $B$.
Following the overestimation property just mentioned, we introduce an abstract transition from $A$ to $B$ whenever we cannot positively rule out such paths.

On the right side we see the abstract state space indicated for the
location $\Heat$. The abstract state space consists of rectangles,
possibly degenerate (extending to $-\infty$ or $+\infty$). For the
bounds of these rectangles one takes the values that occur in the
specification of the hybrid system (see Figure
\ref{fig:thermostat}). According to \cite{alur}, this is a good
choice. (In case one cannot prove safety in this, there is of course
the opportunity for the user to refine it.)  The gray area indicates
that from these states also abstract discrete transitions are
possible. The dashed area is unreachable, because of the invariant for
the $\Heat$ location. %prevents these states from being reachable.  
All the abstract
transitions from the rectangle $[0.5,1) \times[5,6)$ are shown: as the
    temperature flow function for $\Heat$ is $\phi_{\Heat,2}(T,d)= T +
    2 * d$, and the clock flow function is $\phi_{\Heat,1}(c,d) = c +
    d$, these are all the possible abstract transitions.

Using the abstraction method, \cite{alur} proves the correctness of the thermostat.

\begin{center}
\begin{figure}[htb!]
%\begin{turn}{180}
%    \includegraphics[scale=.6, viewport=0 500 700 710, clip]{FIGS/traject}
    \includegraphics[scale=.5]{FIGS/traject}
    \includegraphics[scale=.4]{FIGS/AThermo-new3}
%\end{turn}
\caption{The abstraction function computed
\label{fig:abstraction}}
\end{figure}
\end{center}
\weg{ % because this is explained by Alur already and it is not of particular relevance in our development; we don't refer to it ever again.
There is a slight subtlety with the abstract transitions that we want
to consider. If we just take $\attrans$ to be the reflexive transitive
closure of $\acontrans \cup \adistrans$, we get far too many abstract
traces. (There is no problem with the correctness of the method --
Figure \ref{diag:abstraction} still applies -- but we get way too many
traces to be able to prove any system safe.) The problem lies in the
fact that there is no transition from any point in $[0.5,1)
  \times[5,6)$ to $[0.5,1) \times[9,10)$, but the transitive closure
        of $\adistrans$ gives us such a transition anyway.
}
% \ADAM{I will try to add some more explanation}
\section{Formalisation}
We now describe the Coq formalisation and the design choices made.
We will not pay much attention to the specifics of Coq and its type theory CiC, and will instead focus on concerns relating to the use of computable reals and constructive logic.

The complete sources of the development, as well as a technical report describing the formalization in more detail \cite{hybrid-techreport}, can be found at \newline {\tt http://www.eelis.net/research/hybrid/}.

\subsection{(Concrete) Hybrid Systems}
\label{concrete}

We begin by showing our definition of a concrete system, the different
parts of which we discuss in the remainder of this section.
\begin{code}
Record System: Type :=
  { Point: CSetoid
  ; Location: Set
  ; Location_eq_dec: EqDec Location eq
  ; locations: ExhaustiveList Location
  ; State :=  Location cross Point
  ; initial: State -> Prop
  ; invariant: State -> Prop
  ; invariant_initial: initial subsetof invariant
  ; invariant_stable: forall s, Stable (invariant s)
  ; flow: Location -> Flow Point
  ; guard: State -> Location -> Prop
  ; reset: Location -> Location -> Point -> Point  }.
\end{code}
This Coq definition defines the record type of ``Systems'', which
contains a field ``Point'', representing the continuous state space
and a field ``Location'', representing the set of locations. Here, we
take Point to be an arbitrary constructive setoid, which is basically
just a type with an equality on it. For Location, we assume a
decidable equality and we assume a finite enumeration (``exhaustive
list'') of locations. The other parts are as expected (``Flow Point''
is the type of flow functions on the type ``Point''), except for the
requirement that the invariant $\Inv_l$ is ``Stable'' for every
location $l$.

\subsection{Stability, Double Negation, and Computable Reals}
\label{dn}

\weg{ % wordt later ook genoemd
A property |P| is {\em stable\/} if $\neg \neg P$ implies |P|.
Classically, this is trivially true, but constructively
not.
}
%Especially when we work with real numbers, we don't have $\leltdec: \forall
%x, y \in \IR (x\leq y \vee y<x)$. This conforms with the view of real
%numbers as an infinite sequence of better approximations: if $x$
%converges to $0$ we will not be able to decide $x\leq 0 \vee 0<x$ in a
%finite amount of time.

Constructively, a proof of |X -> A \/ B| is a function that, given an $X$,
returns either a proof of $A$, or a proof of $B$. With this in mind,
suppose we try to implement |le_lt_dec: forall (x, y: CR), (x <= y \/ y < x)|, where |CR| are the constructive reals. Then given $x$ and $y$ in
|CR|, we are to produce a proof either of $x \leq y$ or of $y <
x$. Unfortunately, the nature of computable reals only lets us observe
arbitrarily close approximations of $x$ and $y$. If it happens to be the case that $x =
y$, then no matter how closely we approximate $x$ and $y$, the error
margins (however small) will always leave open the possibility that
$y$ is really smaller than $x$. Consequently, we will never be able to
definitively conclude that $x \leq y$.

Computable reals do admit two variations of the proposition:
%format leltdec_overlap
%format leltdec_DN
%format ~ = "\neg "
\begin{enumerate}
\item |leltdec_overlap: forall (x y: CR), ( x < y -> forall z, (z <= y \/ x <= z))|
\item |leltdec_DN: forall (x y: CR), ~ ~ (x <= y \/ y < x)|
\end{enumerate}

Both are weaker than the original, and are less straightforward to
use. Nevertheless, this is the path we will take in our development,
because just taking |le_lt_dec| as an axiom amounts to cheating.
%and partly because in some parts of the development, we may need to
%really ``run'' these lemmas to obtain $\leq$/$<$ proofs or to do a
%case distinction in an algorithm. Having an axiom, disables such
%algorithms to complete.
\weg{ 
A place where we definitely need the stability of the invariant is in
proving the obvious and useful property of {\em transitivity of the
  continuous transition relation}: Suppose we have $(l, p) \contrans
(l, p')$ and $(l, p')\contrans (l, p'')$ for location $l$ and points
$p, p', p''$. 
To show $(l, p)\contrans (l, p'')$, we must show (among other things)
%that
%$\Exists{d''\in \Dur}{\Phi_l(p, d'') = p''}$ -- for which we
%simply take $d''$ to be the sum of the durations from $p$
%to $p'$ and from $p'$ to $p''$ (call these $d$ and $d'$,
%respectively), and observe:
%\begin{eqnarray*}
%  \Phi_l(p, d + d') & =& \Phi_l( \Phi_l (p, d), d')\\
%    & =& \Phi_l(p', d')\\
%    & =& p'' \nonumber
%\end{eqnarray*}
%What remains is to show 
that the invariant holds at each point along the way. That is,
$$\forall t, 0 \leq t \leq d + d' \rightarrow \Inv_l( \Phi_L(p, t)).$$
We know this is true for $0 \leq t \leq d$, and we know that this is
true for $d \leq t \leq d + d'$. Classically, then, the proof is done,
for one can simply distinguish cases $t \leq d$ or $d < t$.  In our
transitivity proof, we will use the variant expressed using double
negation. Now we need only observe that $x \leq y$ is equivalent to $\neg(y < x)$, and that the law of the excluded middle holds under double negation. That is,
$\forall P( \neg  \neg  (P \vee \neg  P))$
is a trivial tautology.
}
A question that immediately arises is: How does one actually use this
doubly negated variant in proofs?  One practical way is to observe
that double negation, as a function on propositions, is a monad
\cite{wadler95monads}. Writing |DN P| for |~ ~ P|, we have the following two key
operations that make |DN| a monad:

%format return_DN = "\Varid{return}_{DN} "
%format bind_DN
\begin{code}
  return_DN: forall A, A -> DN A
  bind_DN: forall A B, DN A -> (A -> DN B) -> DN B
\end{code}

The first expresses that any previously obtained result can always be
inserted ``into'' the monad. The second expresses that results inside
the monad may be used freely in proofs of additional properties in the
monad. For instance, one may |bind_DN| a proof of $\Varid{DN} (x \leq y \vee y < x)$
(obtained from |leltdec_DN| above) with a proof of $(x \leq y \vee y < x) \rightarrow \Varid{DN} P$, yielding a proof of |DN P|.
 
Thus, |DN| establishes a ``proving context'' in which one may make
use of lemmas yielding results inside |DN| that may not hold outside
of it (such as |leltdec_DN|), as well as lemmas yielding results
not in |DN|, which can always be injected into |DN| using
|return_DN|. The catch is that such proofs always end up with results
in |DN|, which begs the question: what good is any of this? In
particular, can |leltdec_DN| be used to prove anything not doubly
negated?
 
As it happens, some propositions are \emph{stable} in the sense that they are constructively equivalent to their own double negation. Examples include
negations, non-strict inequalities on real numbers, and any decidable
proposition.

Requiring that hybrid system invariants are stable effectively lets us use classical reasoning when showing that invariants holds in certain states. One instance where we need this is in the proof of transitivity of the concrete continuous transition.

\weg{ %referred to something that was already cut
We have seen why we required invariant stability:
%in section \ref{concrete}: 
in the transitivity proof for continuous transitions
it allows
us to employ $\leltdecDN$ to do case distinction on the $t$ variable
when showing that the invariant holds at each point along the
composite path. That is, we simply bind $\leltdecDN t d$ of type
$\DN (t \leq d \vee d < t)$ with the straightforward proof of $(t \leq d
\vee d < t) \rightarrow \DN (\Inv_l(\Phi_l (p, t)))$, and
then pull the latter out of $\DN$ on account of its stability.
}

Invariants are typically conjunctions of inequalities, which are
stable only if the inequalities are non-strict. Hence, the limits on
observability of computable real numbers ultimately mean that our
development cannot cope with hybrid systems whose location invariants
use strict inequalities. We feel that this is not a terrible loss. In
section \ref{abstraction} we will see analogous limitations in the
choice of one's abstraction parameters.
 
%An important point to make here is that the $\DN$ version is also
%\emph{sufficient\/} for proving safety, because the ultimate goal to
%prove is $\forall s\in \State( \Unsafe(s) \rightarrow \neg\Reach(s))$.
%This is a stable proposition, because the conclusion is a negated
%proposition, so is we have prove it ``under $\DN$'' we can extract it
%and conclude safety.

\subsection{Abstract Hybrid Systems}
\label{abshybsys}
\label{abstraction}
We now want to define an abstract system and an abstraction function
satisfying the properties indicated in diagram
\ref{diag:abstraction}. However, this is not possible, because we
cannot make a case distinction like $x\leq 0 \vee 0< x$ and therefore
we can't define a function that sends a point $(c,T)$ to the rectangle $R$
it is in. We can define a function that approximates a point $(c,T)$
up to, say $\epsilon$ ($\epsilon >0$) and then decides to send that
point to the rectangle $R$ the approximation is in. This implies that,
when one is close to the edge of a rectangle,
\begin{itemize}
\item 
different {\em representations\/} of a point $(c,T)$ may be
sent to different rectangles,
\item
a point that is less than $\epsilon$ outside the rectangle $R$ may still be sent to $R$.
\end{itemize}
The second is very problematic, because it means the property for the
abstraction function $A$ depicted in diagram
\ref{diag:abstraction} no longer holds.

We argue that these problems are not merely annoying byproducts
of our use of constructive logic and computable reals, but actually
reflect the profound limitation of physical reality that one can only
ever measure quantities approximately, making case distinctions like
$x\leq 0 \vee 0< x$ simply unrealistic.

Moreover, we claim that the
classical abstraction method allows one to prove the safety of systems
that are unreliable in practice. We will not expand on this here, but
suppose we add a fourth location $\Off$ to the thermostat of Figure
\ref{fig:thermostat}, with $\dot{T} = -1$, $\dot{c} =1$ and an arrow
from $\Heat$ to $\Off$ with guard $c\geq 2 \wedge T<9$. Clearly, if
the system can end up in location $\Off$, it is unsafe. Now, using
the classical abstraction method, there is no transition to any state
involving location $\Off$ from the initial state, because as soon as
$c\geq 2$, $T\geq 9$. However, when we get close to $c=2$, any small
mistake in the measurement of $T$ may send the system to $\Off$,
making the whole hybrid system very unreliable.

The good thing is that we don't really need the property in Diagram
\ref{diag:abstraction}, because we can do something better. 
\begin{itemize}
\item
We let regions in the abstract hybrid systems overlap (ideally as
little as possible, e.g.\ only at the edges).

\item
We replace the abstract transition relations $\acontrans$ and $\distrans$ by functions $\overcontrans$ and $\overdistrans$ that take a region $R_0$
as input and output a {\em list of regions\/} including $R_0$: $(R_o,
R_1, \ldots, R_n)$ in such a way that $\cup_{0\leq i\leq n}R_i$ is an
overapproximation of the set of states reachable by a continuous (resp. discrete) step
from a state in $R_0$.\\
\item
We loosen the requirement on the abstraction function $A$; for $s \in \State$, we only require $\Varid{DN}(\Exists {r\in \Region}{s\in r})$.
\end{itemize}

To summarize, if $s\contrans s'$, then we don't require
$A(s')$ to be in the list $\overcontrans(A(s))$, but we only require
$s'$ to be in the $\bigcup \overcontrans(A(s))$. 
%(Basically it should
%be in one of the regions in the list $\overcontrans(A(s))$.) 
This simple change relieves us from having to determine the exact
regions that points are in: they just should be covered. The functions
$\overcontrans$ and $\overdistrans$ yield a notion of {\em trace\/} in
the abstract hybrid system in the obvious way: starting from $R_0$,
take an $R_1$ in $\overcontrans( R_0)$, then an $R_2$ in
$\overdistrans(R_1)$, and so forth.

Whereas in a concrete hybrid system states consist of a location
paired with a point in the continuous state space, in an abstract
hybrid system states consist of a location paired with the ``name'' of
a region corresponding to a subset of the continuous state space.
From now on we will use a ``|concrete.|'' prefix for names like
|State| defined in section \ref{concrete}, which now have abstract
counterparts. |Region| is a field from a record type |Space| bundling
region sets with related requirements:

\begin{code}
  Record Space: Type :=
    { Region: Set
    ; Region_eq_dec: EqDec Region eq
    ; regions: ExhaustiveList Region
    ; NoDup_regions: NoDup regions
    ; in_region: Container Point Region
    ; regions_cover: forall (l: Location) (p: Point),
        invariant (l, p) -> DN { r: Region | p `elem` r }  }.
\end{code}

The |Container Point Region| type specified for |in_region| reduces to
|Point -> Region -> Prop|. |Container| is a type class that provides
the notation ``|x `elem` y|'', prettier than ``|in_region x
y|''. |regions_cover| expresses that each concrete point belonging to
a valid state must be represented by a region---a crucial ingredient
when arguing that unreachability in the abstract system implies
unreachability in the concrete system. The double negation in its
result type is both necessary and sufficient:

It is \emph{necessary} because |regions_cover| boils down to a
(partial) function that, given a concrete point, must select an
abstract region containing that point. This means that it must be able
to decide on which side of a border between two regions the given
point lies. As we saw in section \ref{dn}, that kind of decidability
is only available inside |DN| unless all region borders have
nontrivial overlap, which as we will see later is undesireable.

Fortunately, the double negation is also \emph{sufficient}, because we
will ultimately only use |regions_cover| in a proof of of |... -> ~
concrete.reachable s| (for some universally quantified variable $s$),
which, due to its head type being a negation, is stable, and can
therefore be proved in and then extracted from |DN|. Hence, we only
need |regions_cover|'s result in |DN|.

\subsection{Underestimation and Overestimation}
\label{estimation}

% It \emph{will} always terminate, so we are not writing a semidecision procedure either.
Ultimately, in our development we are writing a program that
\emph{attempts} to produce hybrid system safety proofs. Importantly,
we are \emph{not} writing a complete hybrid system safety decision
procedure: if the concrete system is unsafe or the abstraction method
fails, our program will simply not produce a safety proof. It might
seem, then, that we are basically writing a \emph{tactic} for a
particular problem domain. However, tactics in Coq are normally
written in a language called Ltac, and typically rely on things like
pattern matching on syntax. Our development, on the other hand, is
very much written in regular Gallina, with hardly any significant use
of Ltac. 

% Eelis: discussion of |option P| variant removed in what follows
We define |underestimation P| to be either a proof of |P|, or not:
\begin{code}
Definition underestimation (P: Prop): Set := { b: bool | b = true -> P }.
\end{code}
Using the |Program| family of commands
\cite{sozeau}, an underestimation may be
provisionally defined strictly as a bool, and then separately proved
to be a valid underestimation in a proof obligation generated by
|Program|. The |bool| in the definition nicely illustrates why we call this an
``underestimation'': it may be |false| even when |P| holds. We can now
describe the functionality of our program by saying that it
underestimates hybrid system safety, yielding a term of type
|underestimation Safe|, where |Safe| is a proposition expressing
safety of a hybrid system.

Considered as theorems, underestimations are not very interesting,
because they can be trivially ``proved'' by taking
|false|. Hence, the value of our program is not witnessed by
the mere fact that it manages to produce terms of type
|underestimation Safe|, but rather by the fact that when run, it
actually manages to returns |true| for the hybrid system we
are interested in (e.g.\ the thermostat). It is for this reason that
we primarily think of the development as a program rather than a
proof, even though the program's purpose is to produce proofs.

The opposite of an underestimation is an overestimation:
\begin{code}
Definition overestimation (P: Prop): Set := { b: bool | b = false -> ~ P }.
\end{code}

Since hybrid system safety is defined as unreachability of unsafe
states, we may equivalently express the functionality of our
development by saying that it overestimates unsafe state
reachability. Indeed, most subroutines in our programs will be
overestimators rather than underestimators. Notions of overestimation
and underestimation trickle down through all layers of our
development, down to basic arithmetic. For instance, we employ
functions such as:

%format CRle_unapplied = <= "_{" CR "}"
%format CRle a b = a <= "_{" CR "}" b
%format Qpos = "\mathbb{Q}^{+}"
%format overestimate_CRle = overestimate "_{" CRle_unapplied "}"

%format epsilon = "\epsilon "

\begin{code}
overestimate_CRle (epsilon: Qpos): forall x y: CR, overestimation (CRle x y)
\end{code}
As discussed earlier, |CRle_unapplied| is not
decidable. |overestimate_CRle| merely makes a ``best effort'' to prove
|~ (CRle x y)| using |epsilon|-approximations. A smaller |epsilon|
will result in fewer spurious |true| results.




\subsection{Abstract Space Construction}
\label{abs.space.constr}

When building an abstract system, one is in principle free to divide
the continuous state space up whichever way one likes. However, if the
regions are too fine-grained, there will have to be very many of them
to cover the continuous state space of the concrete system, resulting
in poor performance. On the other hand, if the regions are too coarse,
they will fail to capture the subtleties of the hybrid system that
allow to prove it safe (if indeed it is safe at all).  Furthermore,
careless use of region overlap can result in undesireable abstract
transitions (and therefore traces), adversely affecting the abstract
system's utility.
%(as we will discuss in detail in section \ref{trouble}).

In \cite{alur}, a heuristic for interval bound selection is described,
where the bounds are taken from the constants that occur in the
invariant, guard, and safety predicates. For the thermostat, we
initially attempted to follow this heuristic and use the same bounds,
but found that due to our use of computable reals, we had to tweak the
bounds somewhat to let the system successfully produce a safety
proof. 
Having to do this ``tweaking'' manually is obviously not ideal. One may want to develop heuristics for this.


Another way in which our thermostat regions differ from \cite{alur}
lies in the fact that our bounds are always inclusive, which means
adjacent regions overlap in lines. We will discuss this in more detail
later.

\subsection{Abstract Transitions and Reachability}
\label{abs.reach}
Once we have a satisfactory abstract |Space|, our goal is to construct
an overestimatable notion of abstract reachability implied by concrete
reachability, so that concrete unreachability results may be obtained
simply by executing the abstract reachability overestimator. We first overestimate the continuous transitions; we need the following definition for that.

%format PowerSet = "\mathcal{P}"
%format `In` = "\in "
\begin{code}
  Definition shared_cover
    (cs: concrete.State -> Prop) (ss: abstract.State -> Prop): Prop :=
        forall s: concrete.State, s `In` cs -> DN (exists r: abstract.State, s `In` r /\ r `In` ss).
\end{code}

A set of concrete states is said to be sharedly-covered
by a set of abstract states if for each of the concrete
states in the former there is an abstract state in the latter that
contains it.


We now specify what the type of |over_cont_trans| should be.
%format `compose` = "\circ "
%format `inter` = "\cap "
\begin{code}
over_cont_trans: forall s: abstract.State,
  { p: list abstract.State | NoDup p /\ shared_cover
    (concrete.invariant `inter` (overlap s `compose` flip concrete.cont_trans)) p }
\end{code}
So, |over_cont_trans s| should produce a list of abstract states |p|
without duplicates,
%(to enhance the graph reachability algorithm that
%we don't detail here, but that will do the actual computation of the
%reachability set), 
such that |p| is a shared cover of the collection
of concrete states |c| that satisfy the invariant and whose set of
origins under |concrete.cont_trans| have an overlap with |s|. In more
mathematical terms: |p| should form a shared cover of $\{ c \in \State
\mid \Inv(c) \wedge s\cap \{c' \mid c' \contrans c\} \neq \emptyset\}$.
We similarly specify |over_disc_trans| as an overestimator for
|concrete_disc_trans| and |over_initial| as an overestimator of
|concrete.initial|. 

We now consider the properties we require for |abstract.reachable|. An obvious candidate is:
\begin{code}
  forall (s: concrete.State), concrete.reachable s ->
    forall (s': abstract.State), s `elem` s' -> abstract.reachable s'.
\end{code}
Which would nicely imply:
\begin{code}
forall (s: concrete.State)
  (exists s': abstract.State, s `elem` s' /\ ~ abstract.reachable s') ->
    ~ concrete.reachable s,
\end{code}
This would expresses that to conclude unreachability of a concrete state,
one need only establish unreachability of \emph{any} abstract state
that contains it. However, this definition neglects to facilitate {\em
  sharing}: remember that a concrete state may be in more then one
abstract state. When abstract states ``share'' the burden of
reachability, one should establish unreachability of \emph{all}
abstract states containing the concrete state. Hence, what we really
want is an |abstract.reachable| satisfying:
\begin{code}
forall s: concrete.State,
  (forall s': abstract.State, s `elem` s' -> ~ abstract.reachable s') ->
  ~ concrete.reachable s.
\end{code}
\weg{
This property follows from the following new definition of |reachable_respect| we will use:
\begin{code}
Definition reachable_respect: Prop :=
  shared_cover concrete.reachable abstract.reachable.
\end{code}
}

\subsection{Underestimating Safety}
\label{underestimatingsafety}

%format `subsetof` = "\subseteq "

In the next section we show that thanks to decidability of our
transition and initiality overstimators, |abstract.reachable| is
decidable. But first we show how a
decision procedure for |abstract.reachable| lets us underestimate
hybrid system safety, and in particular, lets us obtain a proof of
thermostat safety. So suppose we have |reachable_dec: decider abstract.reachable|.
\weg{
And suppose we are given the following specification of unsafe concrete states, covered by a finite list of abstract states:
\begin{code}
  Variables
    (unsafe: concrete.State -> Prop)
    (astates: list abstract.State)
    (astates_cover_unsafe: forall s, unsafe s -> forall r, s `elem` r -> r `elem` astates).
\end{code}

Then, using |reachable_dec| and |unreachable_respect|, we can easily define
\begin{code}
  Definition over_unsafe_reachable: overestimation (overlap unsafe concrete.reachable).
\end{code}
Taking |unsafe := thermo_unsafe| and a suitable abstract cover, we obtain
\begin{code}
  Definition over_thermo_unsafe_reachable:
    overestimation (overlap thermo_unsafe concrete.reachable).
\end{code}
}
Recall that |ThermoSafe| was defined as |thermo_unsafe `subsetof` concrete.unreachable| in section \ref{concrete}. Since we trivially have |~ overlap unsafe concrete.reachable -> ThermoSafe|, we also have:
\begin{code}
Definition under_thermo_unsafe_unreachable: underestimation ThermoSafe.
\end{code}
Using a tiny utility |underestimation_true| of type |forall P (o: underestimation P), o = true -> P|, we can now \emph{run} this underestimator to obtain a proof of the thermostat system's safety:
\begin{code}
Theorem: ThermoSafe.
Proof.
  apply (underestimation_true under_thermo_unsafe_unreachable).
  vm_compute.  reflexivity.
Qed.
\end{code}
The first |apply| reduces the goal to
\begin{code}under_thermo_unsafe_unreachable = true.\end{code} The |vm_compute| tactic invocation then forces evaluation of the left hand side, which will in turn evaluate |over_thermo_unsafe_reachable|, which will evaluate |reachable_dec|, which will evaluate the overestimators of the continuous and discrete transitions. This process, which takes about 35 seconds on a modern desktop machine, eventually reduces |under_thermo_unsafe_unreachable| to |true|, leaving |true = true|, proved by |reflexivity|.

We can now also clearly see what happens when the abstraction method ``fails'' due to poor region selection, overly simplistic transition/initiality overestimators, or plain unsafety of the system. In all these cases, |vm_compute| reduces |under_thermo_unsafe_unreachable| to |false|, and the subsequent |reflexivity| invocation will fail.

This concludes the high level story of our development. What remains
are the implementation of |reachable_dec| in terms of the decidable
overestimators for abstract initiality and continuous and discrete
transitions, and the implementation of those overestimators
themselves. The former is a formally verified graph reachability
algorithm, that we don't detail here. The overestimator for continuous
transitions, |over_cont_trans| will be detailed in the next section
for the thermostat case.

\subsection{Overestimating Continuous Abstract Transitions}
\label{over_cont_trans}

We now discuss the implementation of  |over_cont_trans|:
Given two regions |r_src| and |r_dst|, 
%we want to
%rule out the existence of concrete continuous transitions from points
%in |r_src| to points |r_dst|. Clearly, 
if we can determine that there
are no points in |r_src| which the flow function maps to points in
|r_dst|, then there need be no abstract continuous transition between |r_src|
and |r_dst|. Clearly, this is impossible to
meaningfully overestimate for a general flow function and general
regions. However, the thermostat posesses three key properties that
we can exploit:
\begin{enumerate}
\item its continuous space is of the form $\IR^n$;
\item abstract regions correspond to multiplied $\IR$ intervals;
\item its flow functions are both {\em separable\/} and {\em range invertible}.
\end{enumerate}

The notion of {\em separability\/} has already been discussed in
Section \ref{sec:hybsys}.
%The thermostat's flow function (in any
%location) is separable by construction.

A flow function |f| on |CR| is {\em range invertible\/} if
\begin{code}
  exists (range_inverse: OpenRange -> OpenRange -> OpenRange),
    forall (a: OpenRange) (p: CR), p `elem` a ->
    forall (b: OpenRange) (d: Duration), f p d `elem` b -> d `elem` range_inverse a b
\end{code}
Here, |OpenRange| represents potentially unbounded intervals in $\IR$
(with bounds closed if present. In other words, if $\phi : \IR^2
\rightarrow \IR$ is a flow function with range inverse $F$ and $a,b$
are intervals in $\IR$, then $F(a,b)$ is an interval that contains all
$t$ for which $\phi(x,t)\in b$ for some $x\in a$. 
%So $F(a,b)$ should
%contain all durations $t$ that take some elements of $a$ to some
%element of $b$ via flow $\phi$.
Range invertibility is a less demanding alternative to point invertibility: $\phi^{-1}$ is the {\em point inverse\/} of $\phi$ if $\forall x,y\in \IR (\phi (x, \phi^-1(x,y)) =y)$. So a point inverse $\phi^{-1}(x,y)$ computes the exact time it takes to go from $x$ to $y$ via flow $\phi$.
%We need range invertibility because the exponential flow functions are
%not point invertible.

In the formalization we use a modest library
of flow functions when defining the thermostat's flow. Included in
that library are range-inverses, which consequently automatically
apply to the thermostat's flow. Hence, no ad-hoc work is needed to
show that the thermostat's flow functions are range-invertible.
Having defined the class of separable range-invertible flow functions,
and having argued that the thermostat's flow is in this class, we now
show how to proceed with our overestimation of existence of points in
|r_src| which the flow function map to points in |r_dst|. 
Regions in the abstract space for our thermostat are basically pairs
of regions in the composite spaces, so |r_src| and |r_dst| can be
written as |(r_src_temp, r_src_clock)| and |(r_dst_temp,
r_dst_clock)|, respectively, where each of these four components are
intervals.

We now simply use an |OpenRange| overlap overestimator of type
\begin{code}
Qpos -> forall a b: OpenRange, overestimation (overlap a b)
\end{code}
(defined in terms of things like |overestimate_CRle| shown in section \ref{estimation}) to overestimate whether the following three intervals overlap:
\begin{enumerate}
\item |[0, inf]|
\item |range_inverse temp_flow r_src_temp r_dst_temp|
\item |range_inverse clock_flow r_src_clock r_dst_clock|
\end{enumerate}
For a visual explanation, one may consult the left drawing in Figure
\ref{fig:abstraction} and view |r_src_clock| as $[a_1,b_1]$,
|r_dst_clock| as $[c_1,d_1]$ etc.  Overlap of 2 and 3 is equivalent to
existence of a point in |r_src| from which one can flow to a point in
|r_dst|. After all, if these two range inverses overlap, then there is
a duration |d| that takes a certain temperature value in |r_src_temp|
to a value in |r_dst_temp| and also takes a certain clock value in
|r_src_clock| to a value in |r_dst_clock|. If 2 and 3 do \emph{not}
overlap, then either it takes so long for the temperature to flow from
|r_src_temp| to |r_dst_temp| that any clock value in |r_src_clock|
would ``overshoot'' |r_dst_clock|, or vice versa. Finally, if 1 does
not overlap with 2 and 3, then apparently one could only flow backward
in time, which is not permitted. Hence, overlap of these three ranges
is a necessary condition for existence of concrete flow from points in
|r_src| to points in |r_dst|, and so our |abstract.cont_trans|
overestimator may justifiably return ``false'' when the overlap
overestimator manages to prove absence of overlap.


\section{Related work}

\emph{Verification} of hybrid systems is an active field of research and
there is a number of tools developed with this goal in mind;
see \cite{HST} for a comprehensive list.
Most of them are based on abstract refinement methods, either
using box representations \cite{Kow96,Kow98}
or with polyhedra approximations \cite{alur,Chu99,Cla03}.

Many of those tools are implemented in MATLAB \cite{MATLAB}
and those using some general programming language of choice
most often rely on standard floating point arithmetic, that
comes with its rounding errors. Few tools that address 
this problem include 
PHAVer \cite{PhaVER}, that relies on the Parma Polyhedra Library \cite{Parma} 
for exact computations with non-convex polyhedra 
and 
HSolver \cite{HSolver}, that is based on the constraint solver 
RSolver \cite{RSolver}.

\emph{Formal verification} becomes more and more important, especially in the
field of hybrid systems, which are used to model safety critical systems 
of growing complexity. There has been previous work on using general purpose 
theorem provers for verification of hybrid systems: see \cite{Mum01,Hen98} 
and \cite{Man98,Man01} for works using, respectively, PVS and STeP. 
KeYmaera \cite{KeYmaera} is a dedicated interactive theorem prover for 
specification and verification logic for hybrid systems. It combines
deductive, real algebraic, and computer algebraic prover technologies
and allows users to model hybrid systems, specify their properties
and prove them in a semi-automated way.

However, to the best of our knowledge, none of the previous work nor tools 
relies on a precise model of real number computations completely verified 
in a theorem prover; such as the model of CoRN used in this work.

\section{Conclusions and further research}
The presented verification of hybrid systems in Coq gives a nice
showcase of proof-by-computation-on-computable-reals. The computable
reals in CoRN do really complicated things for us, by approximating
values for various real number expressions at great precision. The
development also contains some nice layers of abstraction, involving
the sophisticated use of type classes, e.g.\ the systematic use of
estimators to make tactic-like optional-deciders, at each level in the
stack and the use of the double negation monad.

It remains to be seen how far this automated verification approach can be
taken, given the fact that we have limited ourselves to hybrid systems
with separable reset and flow functions that are monotone, and with a
stable invariants. There is still a lot of room for more clever
heuristics with less restrictive preconditions. The heuristic in
\cite{alur} for bound selection doesn't work out of the box, but
manual tweaking is obviously not ideal, so some more experimentation
is required here. Finally, in case safety cannot be proved, one would
like the system to generate an ``offending trace'' automatically,
which can the be inspected by the user.

%\bibliographystyle{splncs}
\bibliographystyle{plain}
%\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{paper}

\end{document}
